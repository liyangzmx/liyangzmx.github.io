<!DOCTYPE html>
<html>
<head>
<title>Play.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<ul>
<li><a href="#videoviewopenvideo"><code>VideoView.openVideo()</code></a>
<ul>
<li><a href="#mediaplayer%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE"><code>MediaPlayer</code>的创建与配置</a></li>
<li><a href="#mmediaplayersetonpreparedlistener"><code>mMediaPlayer.setOnPreparedListener()</code></a></li>
<li><a href="#mediaplayersetdatasource"><code>MediaPlayer.setDataSource()</code></a>
<ul>
<li><a href="#native%E5%B1%82mediaplayer%E7%9A%84%E5%88%9B%E5%BB%BA">Native层<code>MediaPlayer</code>的创建</a></li>
<li><a href="#mediaplayersetdatasource-1"><code>MediaPlayer::setDataSource()</code></a></li>
<li><a href="#mediaplayerservicecreate%E5%88%9B%E5%BB%BA%E6%92%AD%E6%94%BE%E5%99%A8"><code>MediaPlayerService::create()</code>创建播放器</a>
<ul>
<li><a href="#mediaplayerserviceclient%E7%9A%84%E5%88%9B%E5%BB%BA"><code>MediaPlayerService::Client</code>的创建</a>
<ul>
<li><a href="#nuplayerdriver%E7%9A%84%E5%88%9B%E5%BB%BA"><code>NuPlayerDriver</code>的创建</a></li>
<li><a href="#nuplayer%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><code>NuPlayer</code>的创建与初始化</a></li>
<li><a href="#audiooutput%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE"><code>AudioOutput</code>的创建与配置</a></li>
</ul>
</li>
<li><a href="#nuplayerdriversetdatasource"><code>NuPlayerDriver::setDataSource()</code></a></li>
<li><a href="#nuplayersetdatasourceasync"><code>NuPlayer::setDataSourceAsync()</code></a></li>
<li><a href="#genericsource%E7%9A%84%E5%88%9B%E5%BB%BA"><code>GenericSource</code>的创建</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mediaplayersetdisplay"><code>MediaPlayer.setDisplay()</code></a>
<ul>
<li><a href="#nuplayerdriversetvideosurfacetexture"><code>NuPlayerDriver::setVideoSurfaceTexture()</code></a></li>
<li><a href="#nuplayersetvideosurfacetextureasync"><code>NuPlayer::setVideoSurfaceTextureAsync()</code></a></li>
</ul>
</li>
<li><a href="#mediaplayerprepareasync"><code>MediaPlayer.prepareAsync()</code></a>
<ul>
<li><a href="#nuplayerdriverprepareasync"><code>NuPlayerDriver::prepareAsync()</code></a></li>
<li><a href="#nuplayerprepareasync"><code>NuPlayer::prepareAsync()</code></a></li>
</ul>
</li>
<li><a href="#mediaplayerstart"><code>MediaPlayer.start()</code></a>
<ul>
<li><a href="#nuplayerdriverstart"><code>NuPlayerDriver::start()</code></a></li>
<li><a href="#nuplayerinstantiatedecoder%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8"><code>NuPlayer::instantiateDecoder()</code>实例化音视频解码器</a></li>
<li><a href="#%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8">视频解码器</a>
<ul>
<li><a href="#%E9%9F%B3%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8">音频解码器</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E7%A0%81%E5%99%A8nuplayerdecoder%E7%9A%84%E6%9E%84%E9%80%A0">解码器<code>NuPlayer::Decoder</code>的构造</a></li>
<li><a href="#%E8%A7%A3%E7%A0%81%E5%99%A8nuplayerdecoder%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">解码器<code>NuPlayer::Decoder</code>的初始化</a></li>
<li><a href="#nuplayerdecoderonconfigure"><code>NuPlayer::Decoder::onConfigure()</code></a>
<ul>
<li><a href="#mediacodeccreatebytype"><code>MediaCodec::CreateByType()</code></a>
<ul>
<li><a href="#mediacodecmediacodec-mediacodec%E7%8A%B6%E6%80%81-uninitialized"><code>MediaCodec::MediaCodec()</code>, <code>MediaCodec</code>状态: <code>UNINITIALIZED</code></a></li>
<li><a href="#mediacodecinit-mediacodec%E7%8A%B6%E6%80%81-uninitialized---initializing---initialized"><code>MediaCodec::init()</code>, <code>MediaCodec</code>状态: <code>UNINITIALIZED</code> -&gt; <code>INITIALIZING</code> -&gt; <code>INITIALIZED</code></a>
<ul>
<li><a href="#ccodec%E7%9A%84%E6%9E%84%E9%80%A0"><code>CCodec</code>的构造</a></li>
<li><a href="#ccodecsetcallback%E9%85%8D%E7%BD%AE%E8%A7%A3%E7%A0%81%E5%99%A8%E5%9B%9E%E8%B0%83"><code>CCodec::setCallback()</code>配置解码器回调</a></li>
<li><a href="#ccodecbufferchannelsetcallback%E9%85%8D%E7%BD%AE%E8%A7%A3%E7%A0%81%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E7%9A%84%E5%9B%9E%E8%B0%83"><code>CCodecBufferChannel::setCallback()</code>配置解码缓冲通道的回调</a></li>
<li><a href="#ccodecinitiateallocatecomponent-mediacodec%E7%8A%B6%E6%80%81-uninitialized---initializing"><code>CCodec::initiateAllocateComponent()</code>, <code>MediaCodec</code>状态: <code>UNINITIALIZED</code> -&gt; <code>INITIALIZING</code></a></li>
<li><a href="#ccodecinitiateallocatecomponent%E5%AE%8C%E6%88%90-mediacodec%E7%8A%B6%E6%80%81-initializing---initialized"><code>CCodec::initiateAllocateComponent()</code>完成, <code>MediaCodec</code>状态: <code>INITIALIZING</code> -&gt; <code>INITIALIZED</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mediacodecconfigure-mediacodec%E7%8A%B6%E6%80%81-initialized---configuring"><code>MediaCodec::configure()</code>, <code>MediaCodec</code>状态: <code>INITIALIZED</code> -&gt; <code>CONFIGURING</code></a>
<ul>
<li><a href="#ccodecinitiateconfigurecomponent-mediacodec%E7%8A%B6%E6%80%81-configuring---configured"><code>CCodec::initiateConfigureComponent()</code>, <code>MediaCodec</code>状态: <code>CONFIGURING</code> -&gt; <code>CONFIGURED</code></a></li>
</ul>
</li>
<li><a href="#mediacodecstart-mediacodec%E7%8A%B6%E6%80%81-configured---starting"><code>MediaCodec::start()</code>, <code>MediaCodec</code>状态: <code>CONFIGURED</code> -&gt; <code>STARTING</code></a>
<ul>
<li><a href="#ccodecinitiatestart-mediacodec%E7%8A%B6%E6%80%81-starting---started"><code>CCodec::initiateStart()</code>, <code>MediaCodec</code>状态: <code>STARTING</code> -&gt; <code>STARTED</code></a></li>
<li><a href="#ccodecstart"><code>CCodec::start()</code></a></li>
<li><a href="#ccodecbufferchannelstart%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97igraphicbufferproducer%E7%9A%84%E9%85%8D%E7%BD%AE"><code>CCodecBufferChannel::start()</code>对视频输出缓冲队列<code>IGraphicBufferProducer</code>的配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9D%A5%E8%87%AAcodec2%E7%9A%84hidllisteneronworkdone">来自<code>Codec2</code>的<code>HidlListener::onWorkDone()</code></a>
<ul>
<li><a href="#objcpy%E5%AE%8C%E6%88%90framedata---c2framedata%E8%BD%AC%E6%8D%A2"><code>objcpy()</code>完成<code>FrameData</code> -&gt; <code>C2FrameData</code>转换</a></li>
<li><a href="#holdbufferqueueblocks%E5%AE%8C%E6%88%90c2constgraphicblock---graphicbuffer%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%AD%98%E5%AF%BC%E5%85%A5"><code>holdBufferQueueBlocks()</code>完成<code>C2ConstGraphicBlock</code> -&gt; <code>GraphicBuffer</code>的图形缓存导入</a></li>
<li><a href="#ccodeconworkdone%E5%AE%8C%E6%88%90graphicbuffer%E7%9A%84%E8%BE%93%E5%87%BA"><code>CCodec::onWorkDone()</code>完成<code>GraphicBuffer</code>的输出</a>
<ul>
<li><a href="#handleoutputformatchangeifneeded%E6%89%93%E5%BC%80%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA"><code>handleOutputFormatChangeIfNeeded()</code>打开音频输出</a></li>
<li><a href="#onoutputbufferavailable"><code>onOutputBufferAvailable()</code></a>
<ul>
<li><a href="#postdrainaudioqueue_l%E5%9B%9E%E6%94%BE%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE"><code>postDrainAudioQueue_l()</code>回放音频数据</a>
<ul>
<li><a href="#audiooutputwrite%E8%BE%93%E5%87%BA%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE"><code>AudioOutput::write()</code>输出音频数据</a>
<ul>
<li><a href="#audiotrackwrite%E5%9B%9E%E6%94%BE%E9%9F%B3%E9%A2%91"><code>AudioTrack::write()</code>回放音频</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#postdrainvideoqueue%E5%9B%9E%E6%94%BE%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE"><code>postDrainVideoQueue()</code>回放视频数据</a>
<ul>
<li><a href="#mediacodeconreleaseoutputbuffer%E9%87%8A%E6%94%BE%E5%B9%B6%E8%BE%93%E5%87%BA%E8%A7%86%E9%A2%91%E5%B8%A7"><code>MediaCodec::onReleaseOutputBuffer()</code>释放(并输出)视频帧</a>
<ul>
<li><a href="#codec2clientcomponentqueuetooutputsurface%E4%BA%A4%E6%8D%A2%E8%A7%86%E9%A2%91%E5%B8%A7%E5%88%B0%E5%BA%94%E7%94%A8%E7%9A%84bbqsurface"><code>Codec2Client::Component::queueToOutputSurface()</code>交换视频帧到应用的<code>BBQSurface</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="videoviewopenvideo"><code>VideoView.openVideo()</code></h1>
<p>用户头一次在相册中点击视频时<code>MovieActivity</code>被创建, 因此:</p>
<pre class="hljs"><code><div>// packages/apps/Gallery2/src/com/android/gallery3d/app/MovieActivity.java
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ... ...
        mPlayer = new MoviePlayer(rootView, this, intent.getData(), savedInstanceState,
                !mFinishOnCompletion) {
            @Override
            public void onCompletion() {
                if (mFinishOnCompletion) {
                    finish();
                }
            }
        };
</div></code></pre>
<p><code>MoviePlayer</code>被构造:</p>
<pre class="hljs"><code><div>// packages/apps/Gallery2/src/com/android/gallery3d/app/MoviePlayer.java
    public MoviePlayer(View rootView, final MovieActivity movieActivity,
            Uri videoUri, Bundle savedInstance, boolean canReplay) {
        mContext = movieActivity.getApplicationContext();
        mRootView = rootView;
        mVideoView = (VideoView) rootView.findViewById(R.id.surface_view);
        ... ...
        mVideoView.setOnErrorListener(this);
        mVideoView.setOnCompletionListener(this);
        mVideoView.setVideoURI(mUri);
        ... ...
    }
</div></code></pre>
<p><code>mVideoView</code>为上文提到的<code>VideoView</code>, 通过其<code>setVideoURI()</code>设置要播放的文件路径:</p>
<pre class="hljs"><code><div>// frameworks/base/core/java/android/widget/VideoView.java
    public void setVideoURI(Uri uri) {
        setVideoURI(uri, null);
    }
    public void setVideoURI(Uri uri, Map&lt;String, String&gt; headers) {
        mUri = uri;
        mHeaders = headers;
        mSeekWhenPrepared = 0;
        openVideo();
        requestLayout();
        invalidate();
    }
</div></code></pre>
<h2 id="mediaplayer%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE"><code>MediaPlayer</code>的创建与配置</h2>
<p>根据上文代码<code>openVideo()</code>被调用:</p>
<pre class="hljs"><code><div>// frameworks/base/core/java/android/widget/VideoView.java
    private void openVideo() {
        ... ...
        try {
            ... ...
            mMediaPlayer = new MediaPlayer();
            ... ...
            mMediaPlayer.setOnPreparedListener(mPreparedListener);
            mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
            mMediaPlayer.setOnCompletionListener(mCompletionListener);
            mMediaPlayer.setOnErrorListener(mErrorListener);
            mMediaPlayer.setOnInfoListener(mInfoListener);
            mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
            mCurrentBufferPercentage = 0;
            mMediaPlayer.setDataSource(mContext, mUri, mHeaders);
            mMediaPlayer.setDisplay(mSurfaceHolder);
            mMediaPlayer.setAudioAttributes(mAudioAttributes);
            mMediaPlayer.setScreenOnWhilePlaying(true);
            mMediaPlayer.prepareAsync();
            ... ...
            for (Pair&lt;InputStream, MediaFormat&gt; pending: mPendingSubtitleTracks) {
                try {
                    mMediaPlayer.addSubtitleSource(pending.first, pending.second);
                    ... ...
            mCurrentState = STATE_PREPARING;
            attachMediaController();
            ... ...
</div></code></pre>
<h2 id="mmediaplayersetonpreparedlistener"><code>mMediaPlayer.setOnPreparedListener()</code></h2>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java
    public void setOnPreparedListener(OnPreparedListener listener)
    {
        mOnPreparedListener = listener;
    }
</div></code></pre>
<p>应用设置了<code>OnPreparedListener</code>到<code>MediaPlayer</code>中, 改监听要等到<code>MediaPlayer.prepareAsync()</code>执行完成才会被调用, 后问会讲到.</p>
<h2 id="mediaplayersetdatasource"><code>MediaPlayer.setDataSource()</code></h2>
<p>先看<code>setDataSource()</code>:</p>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java
    public void setDataSource(@NonNull Context context, @NonNull Uri uri,
            @Nullable Map&lt;String, String&gt; headers)
            throws IOException, IllegalArgumentException, SecurityException, IllegalStateException {
        setDataSource(context, uri, headers, null);
    }
    public void setDataSource(@NonNull Context context, @NonNull Uri uri,
            @Nullable Map&lt;String, String&gt; headers, @Nullable List&lt;HttpCookie&gt; cookies)
            throws IOException {
        ... ...
        if (ContentResolver.SCHEME_FILE.equals(scheme)) {
            ... ...
        } else if (ContentResolver.SCHEME_CONTENT.equals(scheme)
                &amp;&amp; Settings.AUTHORITY.equals(authority)) {
            ... ...
        } else {
            if (attemptDataSource(resolver, uri)) {
                return;
            } .. ...
        }
        ... ...

    private boolean attemptDataSource(ContentResolver resolver, Uri uri) {
        ... ...
        try (AssetFileDescriptor afd = optimize
                ? resolver.openTypedAssetFileDescriptor(uri, &quot;*/*&quot;, opts)
                : resolver.openAssetFileDescriptor(uri, &quot;r&quot;)) {
            setDataSource(afd);
            ... ...

    public void setDataSource(@NonNull AssetFileDescriptor afd)
            throws IOException, IllegalArgumentException, IllegalStateException {
        ... ...
        if (afd.getDeclaredLength() &lt; 0) {
            setDataSource(afd.getFileDescriptor());
            ... ...

    public void setDataSource(FileDescriptor fd)
            throws IOException, IllegalArgumentException, IllegalStateException {
        ... ...
        setDataSource(fd, 0, 0x7ffffffffffffffL);
    }

    public void setDataSource(FileDescriptor fd, long offset, long length)
            throws IOException, IllegalArgumentException, IllegalStateException {
        try (ParcelFileDescriptor modernFd = FileUtils.convertToModernFd(fd)) {
            if (modernFd == null) {
                _setDataSource(fd, offset, length);
            } else ... ...
            ... ...

    private native void _setDataSource(FileDescriptor fd, long offset, long length)
            throws IOException, IllegalArgumentException, IllegalStateException;
</div></code></pre>
<p>经过一系列的调用, <code>_setDataSource()</code>是个Native的方法, 注意该Native方法有两种实现:</p>
<pre class="hljs"><code><div>// frameworks/base/media/jni/android_media_MediaPlayer.cpp
static const JNINativeMethod gMethods[] = {
    ... ...
    {&quot;_setDataSource&quot;,      &quot;(Ljava/io/FileDescriptor;JJ)V&quot;,    (void *)android_media_MediaPlayer_setDataSourceFD},
    {&quot;_setDataSource&quot;,      &quot;(Landroid/media/MediaDataSource;)V&quot;,(void *)android_media_MediaPlayer_setDataSourceCallback },
    ... ...
};

static void
android_media_MediaPlayer_setDataSourceFD(JNIEnv *env, jobject thiz, jobject fileDescriptor, jlong offset, jlong length)
{
    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);
    ... ...
    int fd = jniGetFDFromFileDescriptor(env, fileDescriptor);
    ALOGV(&quot;setDataSourceFD: fd %d&quot;, fd);
    process_media_player_call( env, thiz, mp-&gt;setDataSource(fd, offset, length), &quot;java/io/IOException&quot;, &quot;setDataSourceFD failed.&quot; );
}
</div></code></pre>
<h3 id="native%E5%B1%82mediaplayer%E7%9A%84%E5%88%9B%E5%BB%BA">Native层<code>MediaPlayer</code>的创建</h3>
<p>其<code>mp</code>通过``获得, 而其对应的Java层的<code>MediaPlayer.mNativeContext</code>是在<code>MeidaCodec.native_setup()</code>时设置的:</p>
<pre class="hljs"><code><div>// frameworks/base/media/jni/android_media_MediaPlayer.cpp
static void
android_media_MediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this,
                                       jobject jAttributionSource)
{
    ... ...
    sp&lt;MediaPlayer&gt; mp = new MediaPlayer(attributionSource);
    ... ...
    sp&lt;JNIMediaPlayerListener&gt; listener = new JNIMediaPlayerListener(env, thiz, weak_this);
    mp-&gt;setListener(listener);
    ... ...
    setMediaPlayer(env, thiz, mp);
}

static sp&lt;MediaPlayer&gt; setMediaPlayer(JNIEnv* env, jobject thiz, const sp&lt;MediaPlayer&gt;&amp; player)
{
    Mutex::Autolock l(sLock);
    sp&lt;MediaPlayer&gt; old = (MediaPlayer*)env-&gt;GetLongField(thiz, fields.context);
    ... ...
    env-&gt;SetLongField(thiz, fields.context, (jlong)player.get());
    return old;
}
</div></code></pre>
<p>此处创建了一个<code>JNIMediaPlayerListener</code>, 用于接受<code>MediaPlayer</code>的回调, 而该回调是从<code>mediaerver</code>通过Binder发回的, 在<code>mediaserver</code>中的播放器完成准备工作后会体现到, 此处只关注<code>mp-&gt;setListener()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmedia/mediaplayer.cpp
status_t MediaPlayer::setListener(const sp&lt;MediaPlayerListener&gt;&amp; listener)
{
    ALOGV(&quot;setListener&quot;);
    Mutex::Autolock _l(mLock);
    mListener = listener;
    return NO_ERROR;
}
</div></code></pre>
<p>可以看出<code>JNIMediaPlayerListener</code>作为<code>MediaPlayerListener</code>被<code>MediaPlayer</code>的<code>mListener</code>保存.</p>
<h3 id="mediaplayersetdatasource"><code>MediaPlayer::setDataSource()</code></h3>
<p>上文 <code>env-&gt;SetLongField()</code>设置的正是 <code>mNativeContext</code>. 回到<code>android_media_MediaPlayer_setDataSourceFD()</code>, 此时<code>MediaPlayer::setDataSource()</code>被调用:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmedia/mediaplayer.cpp
status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)
{
    ... ...
    const sp&lt;IMediaPlayerService&gt; service(getMediaPlayerService());
    if (service != 0) {
        sp&lt;IMediaPlayer&gt; player(service-&gt;create(this, mAudioSessionId, mAttributionSource));
        if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
            (NO_ERROR != player-&gt;setDataSource(fd, offset, length))) {
            player.clear();
        }
        err = attachNewPlayer(player);
    }
    return err;
}
</div></code></pre>
<h3 id="mediaplayerservicecreate%E5%88%9B%E5%BB%BA%E6%92%AD%E6%94%BE%E5%99%A8"><code>MediaPlayerService::create()</code>创建播放器</h3>
<h4 id="mediaplayerserviceclient%E7%9A%84%E5%88%9B%E5%BB%BA"><code>MediaPlayerService::Client</code>的创建</h4>
<p>首先通过Binder调用<code>IMediaPlayerService::create()</code>创建一个<code>IMediaPlayer</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
sp&lt;IMediaPlayer&gt; MediaPlayerService::create(const sp&lt;IMediaPlayerClient&gt;&amp; client,
        audio_session_t audioSessionId, const AttributionSourceState&amp; attributionSource)
{
    ... ...
    sp&lt;Client&gt; c = new Client(
            this, verifiedAttributionSource, connId, client, audioSessionId);
    ... ...
    wp&lt;Client&gt; w = c;
    {
        Mutex::Autolock lock(mLock);
        mClients.add(w);
    }
    return c;
}
</div></code></pre>
<p>此处在<code>mediaserver</code>中, <code>Client</code>被构造:</p>
<pre class="hljs"><code><div>MediaPlayerService::Client::Client(
        const sp&lt;MediaPlayerService&gt;&amp; service, const AttributionSourceState&amp; attributionSource,
        int32_t connId, const sp&lt;IMediaPlayerClient&gt;&amp; client,
        audio_session_t audioSessionId)
        : mAttributionSource(attributionSource)
{
    ALOGV(&quot;Client(%d) constructor&quot;, connId);
    mConnId = connId;
    mService = service;
    ... ...
    mAudioSessionId = audioSessionId;
    ... ...
    mListener = new Listener(this);
    ... ....
}
</div></code></pre>
<p><code>mListener</code>后文再说. <code>Client</code>可通过<code>mService</code>与<code>MediaPlayerService</code>交互. 综上所述<code>IMediaPlayer</code>的实现是<code>MediaPlayerService::Client</code>, 后续应用中的<code>MediaPlayer</code>(Native)将通过Binder与此<code>Client</code>通信.回到<code>MediaPlayer::setDataSource()</code>中, 创建完<code>IMediaPlayer</code>后调用<code>player-&gt;setDataSource()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64_t length)
{
    ... ...
    player_type playerType = MediaPlayerFactory::getPlayerType(this,
                                                               fd,
                                                               offset,
                                                               length);
    sp&lt;MediaPlayerBase&gt; p = setDataSource_pre(playerType);
    ... ...
    return mStatus = setDataSource_post(p, p-&gt;setDataSource(fd, offset, length));
    ... ...
}
</div></code></pre>
<h5 id="nuplayerdriver%E7%9A%84%E5%88%9B%E5%BB%BA"><code>NuPlayerDriver</code>的创建</h5>
<p><code>setDataSource_pre()</code>时做了很多工作, 但主要还是创建了<code>MediaPlayerBase</code>, <code>playerType</code>确定了后续需要创建的播放器的类型, Android目前的播放器工厂类默认是<code>NuPlayerFactory</code>(还有一种是<code>TestPlayerFactory</code>):</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::setDataSource_pre(
        player_type playerType)
{
    ... ...
    sp&lt;MediaPlayerBase&gt; p = createPlayer(playerType);
    ... ...
    if (!p-&gt;hardwareOutput()) {
        mAudioOutput = new AudioOutput(mAudioSessionId, mAttributionSource,
                mAudioAttributes, mAudioDeviceUpdatedListener);
        static_cast&lt;MediaPlayerInterface*&gt;(p.get())-&gt;setAudioSink(mAudioOutput);
    }

    return p;
}

sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::createPlayer(player_type playerType)
{
    sp&lt;MediaPlayerBase&gt; p = getPlayer();
    ... ...
    if (p == NULL) {
        p = MediaPlayerFactory::createPlayer(playerType, mListener,
            VALUE_OR_FATAL(aidl2legacy_int32_t_pid_t(mAttributionSource.pid)));
    }
    ... ...
</div></code></pre>
<p>还记得<code>mListener</code>么? 在创建<code>Client</code>时, 它作为<code>Listener</code>被创建, 此时它通过<code>createPlayer()</code>设置给了新创建的播放器.</p>
<p>显然<code>p</code>在一开始是<code>nullptr</code>, <code>MediaPlayerFactory::createPlayer()</code>负责创建播放器:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp
sp&lt;MediaPlayerBase&gt; MediaPlayerFactory::createPlayer(
        player_type playerType,
        const sp&lt;MediaPlayerBase::Listener&gt; &amp;listener,
        pid_t pid) {
    sp&lt;MediaPlayerBase&gt; p;
    ... ...
    factory = sFactoryMap.valueFor(playerType);
    CHECK(NULL != factory);
    p = factory-&gt;createPlayer(pid);
    ... ...
    init_result = p-&gt;initCheck();
    if (init_result == NO_ERROR) {
        p-&gt;setNotifyCallback(listener);
    } else {
        ALOGE(&quot;Failed to create player object of type %d, initCheck failed&quot;
              &quot; (res = %d)&quot;, playerType, init_result);
        p.clear();
    }

    return p;
}
</div></code></pre>
<p>根据上文<code>factory</code>的类型显然是<code>NuPlayerFactory</code>, 因此:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp
class NuPlayerFactory : public MediaPlayerFactory::IFactory {
    public:
        ... ...
    virtual sp&lt;MediaPlayerBase&gt; createPlayer(pid_t pid) {
        ALOGV(&quot; create NuPlayer&quot;);
        return new NuPlayerDriver(pid);
    }
</div></code></pre>
<p>显然<code>NuPlayerDriver</code>被构造:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
NuPlayerDriver::NuPlayerDriver(pid_t pid)
    : ... ...
      mPlayer(new NuPlayer(pid, mMediaClock)),
      ... ...
      mAutoLoop(false) {
    mLooper-&gt;setName(&quot;NuPlayerDriver Looper&quot;);
    mMediaClock-&gt;init();
    // set up an analytics record
    mMetricsItem = mediametrics::Item::create(kKeyPlayer);
    mLooper-&gt;start(
            false, /* runOnCallingThread */
            true,  /* canCallJava */
            PRIORITY_AUDIO);
    mLooper-&gt;registerHandler(mPlayer);
    mPlayer-&gt;init(this);
}
</div></code></pre>
<h5 id="nuplayer%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><code>NuPlayer</code>的创建与初始化</h5>
<p>显然这里有两个调用:</p>
<ul>
<li>NuPlayer::NuPlayer()</li>
<li>NuPlayer::init()</li>
</ul>
<p>先看<code>NuPlayer::NuPlayer()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
NuPlayer::NuPlayer(pid_t pid, const sp&lt;MediaClock&gt; &amp;mediaClock)
    : mUIDValid(false),
      mPID(pid),
      ... ...
      mIsDrmProtected(false),
      mDataSourceType(DATA_SOURCE_TYPE_NONE) {
    CHECK(mediaClock != NULL);
    clearFlushComplete();
}
</div></code></pre>
<p>再看<code>NuPlayer::init()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::init(const wp&lt;NuPlayerDriver&gt; &amp;driver) {
    mDriver = driver;

    sp&lt;AMessage&gt; notify = new AMessage(kWhatMediaClockNotify, this);
    mMediaClock-&gt;setNotificationMessage(notify);
}
</div></code></pre>
<p><code>NuPlayer</code>通过<code>mDriver</code>持有<code>NuPlayerDriver</code>. 此时<code>NuPlayerDriver</code>构造完成, 且其继承关系:<code>MediaPlayerBase</code> -&gt; <code>MediaPlayerInterface</code> -&gt; <code>NuPlayerDriver</code>, <code>kWhatMediaClockNotify</code>本文不讨论.</p>
<p>回到<code>MediaPlayerFactory::createPlayer()</code>, 其完成对<code>NuPlayerDriver</code>的创建后, 通过<code>p-&gt;setNotifyCallback(listener)</code>设置了监听, 此时调用的是<code>NuPlayerDriver</code>的父类<code>MediaPlayerInterface</code>的接口:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/include/MediaPlayerInterface.h

    void        setNotifyCallback(
            const sp&lt;Listener&gt; &amp;listener) {
        Mutex::Autolock autoLock(mNotifyLock);
        mListener = listener;
    }
</div></code></pre>
<p>可以看到<code>MediaPlayerService::Client::Listener</code>被设置到了<code>NuPlayerDriver</code>(父类<code>MediaPlayerInterface</code>)的<code>mListener</code>上, 因此<code>NuPlayerDriver</code>可以通过此对象通知<code>MediaPlayerService::Client</code>的<code>notify()</code>方法, 在<code>prepareAsync()</code>完成后可以看到此类的参与.</p>
<h5 id="audiooutput%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE"><code>AudioOutput</code>的创建与配置</h5>
<p>回到<code>MediaPlayerService::Client::setDataSource_pre()</code>中, <code>AudioOutput</code>被创建, 且通过<code>static_cast&lt;MediaPlayerInterface*&gt;(p.get())-&gt;setAudioSink(mAudioOutput)</code>进行配置:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::setAudioSink(const sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink) {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatSetAudioSink, this);
    msg-&gt;setObject(&quot;sink&quot;, sink);
    msg-&gt;post();
}

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatSetDataSource:
        ... ...
        case kWhatSetAudioSink:
        {
            ... ...
            mAudioSink = static_cast&lt;MediaPlayerBase::AudioSink *&gt;(obj.get());
            break;
        }
        ... ...
</div></code></pre>
<p>此时<code>MediaPlayerService::Client</code>创建的<code>AudioOutput</code>被设置在<code>NuPlayer</code>的<code>mAudioSink</code>.</p>
<h4 id="nuplayerdriversetdatasource"><code>NuPlayerDriver::setDataSource()</code></h4>
<p>而<code>MediaPlayerService::Client::setDataSource()</code>中的<code>p-&gt;setDataSource()</code>是对<code>NuPlayerDriver</code>(<code>MediaPlayerBase</code>的子类)的进一步设置:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
status_t NuPlayerDriver::setDataSource(int fd, int64_t offset, int64_t length) {
    ... ...
    mState = STATE_SET_DATASOURCE_PENDING;
    mPlayer-&gt;setDataSourceAsync(fd, offset, length);
    while (mState == STATE_SET_DATASOURCE_PENDING) {
        mCondition.wait(mLock);
    }
    return mAsyncResult;
}
</div></code></pre>
<h4 id="nuplayersetdatasourceasync"><code>NuPlayer::setDataSourceAsync()</code></h4>
<p>因为调用<code>NuPlayer</code>的<code>setDataSourceAsync()</code>方法是异步的, 此时通过<code>mCondition.wait()</code>等待<code>NuPlayer</code>消息.</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::setDataSourceAsync(const sp&lt;IStreamSource&gt; &amp;source) {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatSetDataSource, this);
    sp&lt;AMessage&gt; notify = new AMessage(kWhatSourceNotify, this);
    msg-&gt;setObject(&quot;source&quot;, new StreamingSource(notify, source));
    msg-&gt;post();
    mDataSourceType = DATA_SOURCE_TYPE_STREAM;
}

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        ... ...
        case kWhatSetDataSource:
        {
            ... ...
            if (obj != NULL) {
                Mutex::Autolock autoLock(mSourceLock);
                mSource = static_cast&lt;Source *&gt;(obj.get());
            } else ... ...
            sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();
            if (driver != NULL) {
                driver-&gt;notifySetDataSourceCompleted(err);
            }
            break;
        }
        ... ...
    }
}
</div></code></pre>
<p><code>notifySetDataSourceCompleted()</code>负责完成对<code>NuPlayerDriver</code>的通知:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
void NuPlayerDriver::notifySetDataSourceCompleted(status_t err) {
    mState = (err == OK) ? STATE_UNPREPARED : STATE_IDLE;
    mCondition.broadcast();
}
</div></code></pre>
<p>上文<code>NuPlayerDriver::setDataSource()</code>通过<code>mCondition.wait(mLock)</code>等待<code>NuPlayer</code>完成, 因此<code>NuPlayerDriver::notifySetDataSourceCompleted()</code>执行完成后 上文的<code>NuPlayerDriver::setDataSource()</code>返回.</p>
<h4 id="genericsource%E7%9A%84%E5%88%9B%E5%BB%BA"><code>GenericSource</code>的创建</h4>
<p>根据上文, <code>mPlayer</code>的类型显然是<code>NuPlayer</code>, 回到<code>uPlayer::setDataSourceAsync()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::setDataSourceAsync(int fd, int64_t offset, int64_t length) {
    ... ...
    sp&lt;GenericSource&gt; source =
            new GenericSource(notify, mUIDValid, mUID, mMediaClock);
    ... ...
    status_t err = source-&gt;setDataSource(fd, offset, length);
    ... ...
}
</div></code></pre>
<p>此处构造了<code>GenericSource</code>, 通过<code>setDataSource()</code>为其设置文件描述符:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp
status_t NuPlayer::GenericSource::setDataSource(
        int fd, int64_t offset, int64_t length) {
    ... ...
    resetDataSource();
    mFd.reset(dup(fd));
    mOffset = offset;
    mLength = length;
    ... ...
}
</div></code></pre>
<p>上层传递的文件描述符被设置在了<code>GenericSource</code>的<code>mFd</code>中, 而<code>GenericSource</code>在<code>NuPlayer::setDataSourceAsync()</code>时通过<code>kWhatSetDataSource</code>消息通知<code>NuPlayer::onMessageReceived()</code>将其记录在<code>NuPlayer</code>的<code>mSource</code>中.</p>
<p>回到上文的<code>MediaPlayerService::Client::setDataSource()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64_t length)
{
    ... ...
    player_type playerType = MediaPlayerFactory::getPlayerType(this,
                                                               fd,
                                                               offset,
                                                               length);
    sp&lt;MediaPlayerBase&gt; p = setDataSource_pre(playerType);
    ... ...
    return mStatus = setDataSource_post(p, p-&gt;setDataSource(fd, offset, length));
    ... ...
}

status_t MediaPlayerService::Client::setDataSource_post(
        const sp&lt;MediaPlayerBase&gt;&amp; p,
        status_t status)
{
    ... ...
    if (mRetransmitEndpointValid) {
        status = p-&gt;setRetransmitEndpoint(&amp;mRetransmitEndpoint);
        if (status != NO_ERROR) {
            ALOGE(&quot;setRetransmitEndpoint error: %d&quot;, status);
        }
    }

    if (status == OK) {
        Mutex::Autolock lock(mLock);
        mPlayer = p;
    }
    return status;
}
</div></code></pre>
<p><code>MediaPlayerService::Client::setDataSource()</code>最后通过<code>setDataSource_post()</code>将创建的<code>NuPlayerDriver</code>设置在<code>MediaPlayerService::Client</code>的<code>mPlayer</code>.</p>
<h2 id="mediaplayersetdisplay"><code>MediaPlayer.setDisplay()</code></h2>
<p>回到<code>VidewView.openVideo()</code>中, <code>mMediaPlayer.setDisplay()</code>将自身的<code>mSurfaceHolder</code>设置给了<code>MediaPlayer</code>:</p>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java
    public void setDisplay(SurfaceHolder sh) {
        mSurfaceHolder = sh;
        Surface surface;
        if (sh != null) {
            surface = sh.getSurface();
        } else {
            surface = null;
        }
        _setVideoSurface(surface);
        updateSurfaceScreenOn();
    }
</div></code></pre>
<p>显然<code>_setVideoSurface()</code>也是Native方法, 直接查看代码:</p>
<pre class="hljs"><code><div>// frameworks/base/media/jni/android_media_MediaPlayer.cpp
static void
android_media_MediaPlayer_setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface)
{
    setVideoSurface(env, thiz, jsurface, true /* mediaPlayerMustBeAlive */);
}

static void
setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)
{
    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);
    ... ...
    decVideoSurfaceRef(env, thiz);
    sp&lt;IGraphicBufferProducer&gt; new_st;
    if (jsurface) {
        sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));
        if (surface != NULL) {
            new_st = surface-&gt;getIGraphicBufferProducer();
            ... ...
            new_st-&gt;incStrong((void*)decVideoSurfaceRef);
        } else ... ...
    }
    env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());
    mp-&gt;setVideoSurfaceTexture(new_st);
}
</div></code></pre>
<p>通过<code>android_view_Surface_getSurface()</code>将上层的<code>Surface</code>(Java)转换为底层的<code>Surface</code>(Native), 然后将该<code>Surface</code>(Native)指针记录在<code>MediaPlayer.mNativeSurfaceTexture</code>(Java)中, 最后通过<code>mp-&gt;setVideoSurfaceTexture()</code>也就是<code>MediaPlayer::setVideoSurfaceTexture()</code>设置从<code>Surface</code>(Native)调用<code>getIGraphicBufferProducer()</code>获得的<code>IGraphicBufferProducer</code>给底层的MediaPlayer(Native):</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmedia/mediaplayer.cpp
status_t MediaPlayer::setVideoSurfaceTexture(
        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)
{
    ... ...
    return mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);
}
</div></code></pre>
<p><code>mPlayer-&gt;setVideoSurfaceTexture()</code>通过Binder调用到:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
status_t MediaPlayerService::Client::setVideoSurfaceTexture(
        const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)
{
    ... ...
    sp&lt;MediaPlayerBase&gt; p = getPlayer();
    ... ...
    sp&lt;ANativeWindow&gt; anw;
    if (bufferProducer != NULL) {
        anw = new Surface(bufferProducer, true /* controlledByApp */);
        status_t err = nativeWindowConnect(anw.get(), &quot;setVideoSurfaceTexture&quot;);
        ... ...
    }
    status_t err = p-&gt;setVideoSurfaceTexture(bufferProducer);
    mLock.lock();
    disconnectNativeWindow_l();
    if (err == OK) {
        mConnectedWindow = anw;
        mConnectedWindowBinder = binder;
        mLock.unlock();
    } else ... ...
</div></code></pre>
<h3 id="nuplayerdriversetvideosurfacetexture"><code>NuPlayerDriver::setVideoSurfaceTexture()</code></h3>
<p>通过上层传递的<code>bufferProducer</code>创建了新的<code>Surface</code>, 又通过<code>disconnectNativeWindow_l()</code>断开了<code>bufferProducer</code>与应用持有的<code>Surface</code>(Native)的联系, 然后将新创建的<code>Surface</code>保存到<code>Client::mConnectedWindow</code>, 这意味着, <code>mediaserver</code>直接负责生产<code>GraphicBuffer</code>给原本属于应用持有的<code>Surface</code>. 继续看此处的<code>p-&gt;setVideoSurfaceTexture()</code>, <code>p</code>的类型为<code>MediaPlayerBase</code>, 也就是<code>NuPlayerDriver</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
status_t NuPlayerDriver::setVideoSurfaceTexture(
        const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) {
    mSetSurfaceInProgress = true;
    mPlayer-&gt;setVideoSurfaceTextureAsync(bufferProducer);
    while (mSetSurfaceInProgress) {
        mCondition.wait(mLock);
    }
    return OK;
}
</div></code></pre>
<h3 id="nuplayersetvideosurfacetextureasync"><code>NuPlayer::setVideoSurfaceTextureAsync()</code></h3>
<p>如上文, <code>mPlayer</code>的类型是<code>NuPlayer</code>, 和上文的<code>NuPlayer::setDataSource()</code>类似, <code>setVideoSurfaceTextureAsync()</code>也是异步的:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::setVideoSurfaceTextureAsync(
        const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatSetVideoSurface, this);

    if (bufferProducer == NULL) {
        msg-&gt;setObject(&quot;surface&quot;, NULL);
    } else {
        msg-&gt;setObject(&quot;surface&quot;, new Surface(bufferProducer, true /* controlledByApp */));
    }
    msg-&gt;post();
}

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatSetDataSource:
        ... ...
        case kWhatSetVideoSurface:
        {

            sp&lt;RefBase&gt; obj;
            CHECK(msg-&gt;findObject(&quot;surface&quot;, &amp;obj));
            sp&lt;Surface&gt; surface = static_cast&lt;Surface *&gt;(obj.get());
            if (mSource == NULL || !mStarted || mSource-&gt;getFormat(false /* audio */) == NULL
                    // NOTE: mVideoDecoder's mSurface is always non-null
                    || (mVideoDecoder != NULL &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) {
                performSetSurface(surface);
                break;
            }
            ... ...
        }
        ... ...
    }
}
void NuPlayer::performSetSurface(const sp&lt;Surface&gt; &amp;surface) {
    mSurface = surface;
    setVideoScalingMode(mVideoScalingMode);
    if (mDriver != NULL) {
        sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();
        if (driver != NULL) {
            driver-&gt;notifySetSurfaceComplete();
        }
    }
}
</div></code></pre>
<p>注意, 在<code>NuPlayer::onMessageReceived()</code>响应消息<code>kWhatSetVideoSurface</code>时, 条件<code>!mStarted</code>成立. <code>NuPlayer</code>保存上层的<code>Surface</code>即<code>mediaserver</code>使用应用传递的<code>IGraphicBufferProducer</code>所创建的<code>Surface</code>到<code>mSurface</code>, 并调用<code>NuPlayerDriver::notifySetSurfaceComplete()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
void NuPlayerDriver::notifySetSurfaceComplete() {
    ... ...
    mSetSurfaceInProgress = false;
    mCondition.broadcast();
}
</div></code></pre>
<p>同理可知<code>NuPlayerDriver::setVideoSurfaceTexture()</code>返回.</p>
<h2 id="mediaplayerprepareasync"><code>MediaPlayer.prepareAsync()</code></h2>
<p>回到<code>VidewView.openVideo()</code>中, <code>mMediaPlayer.prepareAsync()</code>即开始通知播放器做准备工作:</p>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java
public class MediaPlayer extends PlayerBase
                         implements SubtitleController.Listener
                                  , VolumeAutomation
                                  , AudioRouting
{
    .. ...
    public native void prepareAsync() throws IllegalStateException;
</div></code></pre>
<p><code>prepareAsync()</code>是个本地方法:</p>
<pre class="hljs"><code><div>// frameworks/base/media/jni/android_media_MediaPlayer.cpp
static const JNINativeMethod gMethods[] = {
    ... ...
    {&quot;prepareAsync&quot;,        &quot;()V&quot;,                              (void *)android_media_MediaPlayer_prepareAsync},
    ... ...
};

static void
android_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)
{
    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);
    ... ...
    // Handle the case where the display surface was set before the mp was
    // initialized. We try again to make it stick.
    sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz);
    mp-&gt;setVideoSurfaceTexture(st);
    process_media_player_call( env, thiz, mp-&gt;prepareAsync(), &quot;java/io/IOException&quot;, &quot;Prepare Async failed.&quot; );
}
</div></code></pre>
<h3 id="nuplayerdriverprepareasync"><code>NuPlayerDriver::prepareAsync()</code></h3>
<p><code>NuPlayerDriver::setVideoSurfaceTexture()</code>的调用是多余的, 但并没什么坏处:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
status_t NuPlayerDriver::prepareAsync() {
    ... ..
    switch (mState) {
        case STATE_UNPREPARED:
            mState = STATE_PREPARING;
            mIsAsyncPrepare = true;
            mPlayer-&gt;prepareAsync();
            return OK;
        case STATE_STOPPED:
            ... ...
        default:
            return INVALID_OPERATION;
    };
}

</div></code></pre>
<h3 id="nuplayerprepareasync"><code>NuPlayer::prepareAsync()</code></h3>
<p>播放器的状态如果是还未播放过, 那肯定是<code>STATE_UNPREPARED</code>, <code>STATE_STOPPED</code>的情景这里不讨论:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::prepareAsync() {
    ... ...
    (new AMessage(kWhatPrepare, this))-&gt;post();
}

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatSetDataSource:
        ... ...
        case kWhatPrepare:
        {
            ... ...
            mSource-&gt;prepareAsync();
            break;
        }
        ... ...
</div></code></pre>
<p>如上文<code>mSource</code>的类型是<code>GenericSource</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp
void NuPlayer::GenericSource::prepareAsync() {
    ... ...
    if (mLooper == NULL) {
        mLooper = new ALooper;
        mLooper-&gt;setName(&quot;generic&quot;);
        mLooper-&gt;start();
        mLooper-&gt;registerHandler(this);
    }
    sp&lt;AMessage&gt; msg = new AMessage(kWhatPrepareAsync, this);
    msg-&gt;post();
}
void NuPlayer::GenericSource::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    Mutex::Autolock _l(mLock);
    switch (msg-&gt;what()) {
        case kWhatPrepareAsync:
        {
            onPrepareAsync();
            break;
        }
        ... ...
    }
}

void NuPlayer::GenericSource::onPrepareAsync() {
    ... ...
    // delayed data source creation
    if (mDataSource == NULL) {
        ... ...
    }
    ... ...
    // init extractor from data source
    status_t err = initFromDataSource();
    ... ...
    if (mVideoTrack.mSource != NULL) {
        ... ...
    }
    notifyFlagsChanged(
            // FLAG_SECURE will be known if/when prepareDrm is called by the app
            // FLAG_PROTECTED will be known if/when prepareDrm is called by the app
            FLAG_CAN_PAUSE |
            FLAG_CAN_SEEK_BACKWARD |
            FLAG_CAN_SEEK_FORWARD |
            FLAG_CAN_SEEK);
    finishPrepareAsync();
    ... ...
}
void NuPlayer::GenericSource::finishPrepareAsync() {
    ... ...
    status_t err = startSources();
    ... ...
    if (mIsStreaming) {
        ... ...
    } else {
        notifyPrepared();
    }
    ... ...
}
</div></code></pre>
<p>大体说下这里, 主要是准备<code>DataSource</code>并设置给<code>mDataSource</code>, 该步骤不能失败, 如果成功, 且初始化没有问题, 则最终通过父类<code>NuPlayer::Source</code>的<code>notifyPrepared()</code>方法通知<code>NuPlayerDriver</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::Source::notifyPrepared(status_t err) {
    ... ...
    sp&lt;AMessage&gt; notify = dupNotify();
    notify-&gt;setInt32(&quot;what&quot;, kWhatPrepared);
    notify-&gt;setInt32(&quot;err&quot;, err);
    notify-&gt;post();
}
</div></code></pre>
<p><code>NuPlayerDriver</code>处理<code>NuPlayer::Source::kWhatPrepared</code>消息:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        ... ...
        case Source::kWhatPrepared:
        {
            ... ...
            if (err != OK) {
                ... ...
            } else {
                mPrepared = true;
            }

            sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();
            if (driver != NULL) {
                ... ...
                if (mSource-&gt;getDuration(&amp;durationUs) == OK) {
                    driver-&gt;notifyDuration(durationUs);
                }
                driver-&gt;notifyPrepareCompleted(err);
            }

            break;
        }
        ... ...
    }
}
</div></code></pre>
<p><code>NuPlayer</code>通过<code>NuPlayerDriver::notifyPrepareCompleted()</code>通知完成操作:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp

void NuPlayerDriver::notifyPrepareCompleted(status_t err) {
    ... ...
    mAsyncResult = err;
    if (err == OK) {
        // update state before notifying client, so that if client calls back into NuPlayerDriver
        // in response, NuPlayerDriver has the right state
        mState = STATE_PREPARED;
        if (mIsAsyncPrepare) {
            notifyListener_l(MEDIA_PREPARED);
        }
    } else ... ...
    sp&lt;MetaData&gt; meta = mPlayer-&gt;getFileMeta();
    int32_t loop;
    if (meta != NULL
            &amp;&amp; meta-&gt;findInt32(kKeyAutoLoop, &amp;loop) &amp;&amp; loop != 0) {
        mAutoLoop = true;
    }
    mCondition.broadcast();
}
</div></code></pre>
<p>然而, <code>mCondition.broadcast()</code>的消息并没有对应的<code>mCondition.wait()</code>, 这是因为<code>NuPlayerDriver</code>实际上是通过<code>notifyListener_l()</code>同时上层的, 消息是<code>MEDIA_PREPARED</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
void NuPlayerDriver::notifyListener_l(
    int msg, int ext1, int ext2, const Parcel *in) {
    ALOGV(&quot;notifyListener_l(%p), (%d, %d, %d, %d), loop setting(%d, %d)&quot;,
            this, msg, ext1, ext2, (in == NULL ? -1 : (int)in-&gt;dataSize()), mAutoLoop, mLooping);
    switch (msg) {
        case MEDIA_PLAYBACK_COMPLETE:
        ... ...
    }
    mLock.unlock();
    sendEvent(msg, ext1, ext2, in);
    mLock.lock();
}
</div></code></pre>
<p>此处的<code>sendEvent()</code>方法是<code>NuPlayerDriver</code>父类<code>MediaPlayerBase</code>的:</p>
<pre class="hljs"><code><div>// frameworks/av/include/media/MediaPlayerInterface.h
class MediaPlayerBase : public RefBase
{
public:
    ... ...
    void        sendEvent(int msg, int ext1=0, int ext2=0,
                          const Parcel *obj=NULL) {
        sp&lt;Listener&gt; listener;
        {
            Mutex::Autolock autoLock(mNotifyLock);
            listener = mListener;
        }
        if (listener != NULL) {
            listener-&gt;notify(msg, ext1, ext2, obj);
        }
    }
    ... ...
</div></code></pre>
<p><code>mPlayer</code>的类型是<code>MediaPlayerBase::Listener</code>, 其还有一个子实现:<code>MediaPlayerService::Client::Listener</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.h
class MediaPlayerService : public BnMediaPlayerService
{
    ... ...
    class Client : public BnMediaPlayer {
        ... ...
        class Listener : public MediaPlayerBase::Listener {
        public:
            Listener(const wp&lt;Client&gt; &amp;client) : mClient(client) {}
            virtual ~Listener() {}
            virtual void notify(int msg, int ext1, int ext2, const Parcel *obj) {
                sp&lt;Client&gt; client = mClient.promote();
                if (client != NULL) {
                    client-&gt;notify(msg, ext1, ext2, obj);
                }
            }
        private:
            wp&lt;Client&gt; mClient;
        };
        ... ...
</div></code></pre>
<p>综上所述<code>MediaPlayerService::Client::notify()</code>被调用:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
void MediaPlayerService::Client::notify(
        int msg, int ext1, int ext2, const Parcel *obj)
{
    sp&lt;IMediaPlayerClient&gt; c;
    sp&lt;Client&gt; nextClient;
    status_t errStartNext = NO_ERROR;
    {
        Mutex::Autolock l(mLock);
        c = mClient;
        ... ...
    }
    ... ...
    if (c != NULL) {
        ALOGV(&quot;[%d] notify (%d, %d, %d)&quot;, mConnId, msg, ext1, ext2);
        c-&gt;notify(msg, ext1, ext2, obj);
    }
}
</div></code></pre>
<p><code>IMediaPlayerClient</code>将调用回应用的<code>MediaPlayer</code>, 因此应用的<code>MediaPlayer::notify()</code>通过Binder被调用:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmedia/mediaplayer.cpp
void MediaPlayer::notify(int msg, int ext1, int ext2, const Parcel *obj)
{
    ... ...
    switch (msg) {
    case MEDIA_NOP: // interface test message
        break;
    case MEDIA_PREPARED:
        ALOGV(&quot;MediaPlayer::notify() prepared&quot;);
        mCurrentState = MEDIA_PLAYER_PREPARED;
        if (mPrepareSync) {
            ALOGV(&quot;signal application thread&quot;);
            mPrepareSync = false;
            mPrepareStatus = NO_ERROR;
            mSignal.signal();
        }
        break;
        ... ...
    }
    sp&lt;MediaPlayerListener&gt; listener = mListener;
    if (locked) mLock.unlock();
    // this prevents re-entrant calls into client code
    if ((listener != 0) &amp;&amp; send) {
        Mutex::Autolock _l(mNotifyLock);
        ALOGV(&quot;callback application&quot;);
        listener-&gt;notify(msg, ext1, ext2, obj);
        ALOGV(&quot;back from callback&quot;);
    }
}
</div></code></pre>
<p><code>mSignal.signal()</code>此场景下没有流程在等待(只有<code>MediaPlayer::notify()</code>时才等待), 此时<code>mListener</code>的类型是<code>MediaPlayerListener</code>, 其实现是<code>JNIMediaPlayerListener</code>, 因此:</p>
<pre class="hljs"><code><div>// frameworks/base/media/jni/android_media_MediaPlayer.cpp
void JNIMediaPlayerListener::notify(int msg, int ext1, int ext2, const Parcel *obj)
{
    JNIEnv *env = AndroidRuntime::getJNIEnv();
    if (obj &amp;&amp; obj-&gt;dataSize() &gt; 0) {
        jobject jParcel = createJavaParcelObject(env);
        if (jParcel != NULL) {
            Parcel* nativeParcel = parcelForJavaObject(env, jParcel);
            nativeParcel-&gt;setData(obj-&gt;data(), obj-&gt;dataSize());
            env-&gt;CallStaticVoidMethod(mClass, fields.post_event, mObject,
                    msg, ext1, ext2, jParcel);
            env-&gt;DeleteLocalRef(jParcel);
        }
    } else {
        env-&gt;CallStaticVoidMethod(mClass, fields.post_event, mObject,
                msg, ext1, ext2, NULL);
    }
    if (env-&gt;ExceptionCheck()) {
        ALOGW(&quot;An exception occurred while notifying an event.&quot;);
        LOGW_EX(env);
        env-&gt;ExceptionClear();
    }
}
</div></code></pre>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java
public class MediaPlayer extends PlayerBase
                         implements SubtitleController.Listener
                                  , VolumeAutomation
                                  , AudioRouting
{
    ... ...
    private static void postEventFromNative(Object mediaplayer_ref,
                                            int what, int arg1, int arg2, Object obj)
    {
        final MediaPlayer mp = (MediaPlayer)((WeakReference)mediaplayer_ref).get();
        ... ...
        switch (what) {
            ... ...
        case MEDIA_PREPARED:
            // By this time, we've learned about DrmInfo's presence or absence. This is meant
            // mainly for prepareAsync() use case. For prepare(), this still can run to a race
            // condition b/c MediaPlayerNative releases the prepare() lock before calling notify
            // so we also set mDrmInfoResolved in prepare().
            synchronized (mp.mDrmLock) {
                mp.mDrmInfoResolved = true;
            }
            break;

        }
        if (mp.mEventHandler != null) {
            Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);
            mp.mEventHandler.sendMessage(m);
        }
    }
</div></code></pre>
<p><code>mEventHandler</code>的类型是<code>MediaPlayer.EventHandler</code>故:</p>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java

    private class EventHandler extends Handler
    {
        private MediaPlayer mMediaPlayer;

        public EventHandler(MediaPlayer mp, Looper looper) {
            super(looper);
            mMediaPlayer = mp;
        }

        @Override
        public void handleMessage(Message msg) {
            if (mMediaPlayer.mNativeContext == 0) {
                Log.w(TAG, &quot;mediaplayer went away with unhandled events&quot;);
                return;
            }
            switch(msg.what) {
            case MEDIA_PREPARED:
                try {
                    scanInternalSubtitleTracks();
                } catch (RuntimeException e) {
                    // send error message instead of crashing;
                    // send error message instead of inlining a call to onError
                    // to avoid code duplication.
                    Message msg2 = obtainMessage(
                            MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, MEDIA_ERROR_UNSUPPORTED, null);
                    sendMessage(msg2);
                }

                OnPreparedListener onPreparedListener = mOnPreparedListener;
                if (onPreparedListener != null)
                    onPreparedListener.onPrepared(mMediaPlayer);
                return;
                ... ...
</div></code></pre>
<p>而<code>mOnPreparedListener</code>是上层通过<code>setOnPreparedListener()</code>设置的. 其实现:</p>
<pre class="hljs"><code><div>// frameworks/base/core/java/android/widget/VideoView.java
    @UnsupportedAppUsage
    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
        public void onPrepared(MediaPlayer mp) {
            mCurrentState = STATE_PREPARED;

            // Get the capabilities of the player for this stream
            Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
                                      MediaPlayer.BYPASS_METADATA_FILTER);
            ... ...
            mVideoWidth = mp.getVideoWidth();
            mVideoHeight = mp.getVideoHeight();
            ... ...
            if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) {
                ... ...
            } else {
                // We don't know the video size yet, but should start anyway.
                // The video size might be reported to us later.
                if (mTargetState == STATE_PLAYING) {
                    start();
                }
            }
        }
    };
</div></code></pre>
<p>此时视频的播放仍未开始, 因此<code>if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0)</code>条件不成立, 且此时<code>if (mTargetState == STATE_PLAYING)</code>条件也不满足.</p>
<h2 id="mediaplayerstart"><code>MediaPlayer.start()</code></h2>
<p>回到<code>MoviePlayer</code>的构造:</p>
<pre class="hljs"><code><div>// packages/apps/Gallery2/src/com/android/gallery3d/app/MoviePlayer.java
    public MoviePlayer(View rootView, final MovieActivity movieActivity,
            Uri videoUri, Bundle savedInstance, boolean canReplay) {
        mContext = movieActivity.getApplicationContext();
        mRootView = rootView;
        mVideoView = (VideoView) rootView.findViewById(R.id.surface_view);
        ... ...
        mVideoView.setOnErrorListener(this);
        mVideoView.setOnCompletionListener(this);
        mVideoView.setVideoURI(mUri);
        ... ...
        mVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
            @Override
            public void onPrepared(MediaPlayer player) {
                ... ...
            }
        });
        ... ...
        if (savedInstance != null) { // this is a resumed activity
            ... ...
        } else {
            final Integer bookmark = mBookmarker.getBookmark(mUri);
            if (bookmark != null) {
                showResumeDialog(movieActivity, bookmark);
            } else {
                startVideo();
            }
        }
    }
    private void startVideo() {
        ... ...
        mVideoView.start();
        setProgress();
    }
</div></code></pre>
<p><code>mVideoView</code>是上文的<code>VideoView</code>:</p>
<pre class="hljs"><code><div>// frameworks/base/core/java/android/widget/VideoView.java
    @Override
    public void start() {
        if (isInPlaybackState()) {
            mMediaPlayer.start();
            mCurrentState = STATE_PLAYING;
        }
        mTargetState = STATE_PLAYING;
    }
</div></code></pre>
<p>终于调用到<code>MediaPlayer.start()</code>了, 为了节省篇幅, 我们都写到一起:</p>
<pre class="hljs"><code><div>// frameworks/base/media/java/android/media/MediaPlayer.java
public class MediaPlayer extends PlayerBase
                         implements SubtitleController.Listener
                                  , VolumeAutomation
                                  , AudioRouting
{
    ... ...
    public void start() throws IllegalStateException {
        //FIXME use lambda to pass startImpl to superclass
        final int delay = getStartDelayMs();
        if (delay == 0) {
            startImpl();
        } else ... // 单独启动线程做延迟处理, 此处不考虑
    }

    private void startImpl() {
        baseStart(0); // unknown device at this point
        stayAwake(true);
        tryToEnableNativeRoutingCallback();
        _start();
    }
    private native void _start() throws IllegalStateException;
    ... ...
}
</div></code></pre>
<h3 id="nuplayerdriverstart"><code>NuPlayerDriver::start()</code></h3>
<pre class="hljs"><code><div>// frameworks/base/media/jni/android_media_MediaPlayer.cpp
static const JNINativeMethod gMethods[] = {
    ... ...
    {&quot;_start&quot;,              &quot;()V&quot;,                              (void *)android_media_MediaPlayer_start},
    ... ...
}
static void
android_media_MediaPlayer_start(JNIEnv *env, jobject thiz)
{
    ... ...
    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);
    ... ...
    process_media_player_call( env, thiz, mp-&gt;start(), NULL, NULL );
}

### `NuPlayer::start()`
// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
status_t NuPlayerDriver::start() {
    ALOGV(&quot;start(%p), state is %d, eos is %d&quot;, this, mState, mAtEOS);
    Mutex::Autolock autoLock(mLock);
    return start_l();
}
status_t NuPlayerDriver::start_l() {
    switch (mState) {
        // 此时状态必定为 STATE_PREPARED
        case STATE_UNPREPARED:
        ... ...
        case STATE_PAUSED:
        case STATE_STOPPED_AND_PREPARED:
        case STATE_PREPARED:
        {
            mPlayer-&gt;start();
            FALLTHROUGH_INTENDED;
        }
        ... ...
    }
    mState = STATE_RUNNING;
    return OK;
}

// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
void NuPlayer::start() {
    (new AMessage(kWhatStart, this))-&gt;post();
}

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatSetDataSource:
        ... ...
        case kWhatStart:
        {
            // 显然 mStarted 为: false
            if (mStarted) {
                ... ...
            } else {
                onStart();
            }
            mPausedByClient = false;
            break;
        }
        ... ....
    }
}

void NuPlayer::onStart(int64_t startPositionUs, MediaPlayerSeekMode mode) {
    ... ...
    mRenderer = new Renderer(mAudioSink, mMediaClock, notify, flags);
    if (mVideoDecoder != NULL) {
        mVideoDecoder-&gt;setRenderer(mRenderer);
    }
    if (mAudioDecoder != NULL) {
        mAudioDecoder-&gt;setRenderer(mRenderer);
    }
    ... ...
    postScanSources();
}

// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
NuPlayer::Renderer::Renderer(
        const sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink,
        const sp&lt;MediaClock&gt; &amp;mediaClock,
        const sp&lt;AMessage&gt; &amp;notify,
        uint32_t flags)
    : mAudioSink(sink),
      ... ...
      mWakeLock(new AWakeLock()) {
    CHECK(mediaClock != NULL);
    mPlaybackRate = mPlaybackSettings.mSpeed;
    mMediaClock-&gt;setPlaybackRate(mPlaybackRate);
    (void)mSyncFlag.test_and_set();
}
</div></code></pre>
<p><code>NuPlayer</code>的<code>mAudioSink</code>也就是<code>AudioOutput</code>被设置给了<code>NuPlayer::Renderer</code>的<code>mAudioSink</code>成员, 后续渲染时, 此处会用到.
通过<code>setRenderer()</code>, <code>NuPlayer::Renderer</code>均设置到了<code>mVideoDecoder</code>和<code>mAudioDecoder</code>所对应的<code>CCodec</code>的父类<code>CodecBase</code>的<code>mRender</code>中(过程略去).</p>
<h3 id="nuplayerinstantiatedecoder%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8"><code>NuPlayer::instantiateDecoder()</code>实例化音视频解码器</h3>
<p>对于<code>NuPlayer::onStart()</code>, 接着接看<code>postScanSources()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
void NuPlayer::postScanSources() {
    if (mScanSourcesPending) {
        return;
    }

    sp&lt;AMessage&gt; msg = new AMessage(kWhatScanSources, this);
    msg-&gt;setInt32(&quot;generation&quot;, mScanSourcesGeneration);
    msg-&gt;post();

    mScanSourcesPending = true;
}

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatSetDataSource:
        ... ...
        case kWhatScanSources:
        {
            ... ...
            // initialize video before audio because successful initialization of
            // video may change deep buffer mode of audio.
            if (mSurface != NULL) {
                if (instantiateDecoder(false, &amp;mVideoDecoder) == -EWOULDBLOCK) {
                    rescan = true;
                }
            }
            ... ...
        }
        ... ...
    }
}
</div></code></pre>
<h3 id="%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8">视频解码器</h3>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
status_t NuPlayer::instantiateDecoder(
        bool audio, sp&lt;DecoderBase&gt; *decoder, bool checkAudioModeChange) {
    ... ...
    if (!audio) {
        ... ...
        if (mCCDecoder == NULL) {
            mCCDecoder = new CCDecoder(ccNotify);
        }
        ... ...
    }
    ... ...
    if (audio) {
        ... ...
    } else {
        ... ...
        *decoder = new Decoder(
                notify, mSource, mPID, mUID, mRenderer, mSurface, mCCDecoder);
        mVideoDecoderError = false;
        ... ...
    }
    (*decoder)-&gt;init();
    ... ...
    (*decoder)-&gt;configure(format);
    ... ...
}
</div></code></pre>
<h4 id="%E9%9F%B3%E9%A2%91%E8%A7%A3%E7%A0%81%E5%99%A8">音频解码器</h4>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
status_t NuPlayer::instantiateDecoder(
        bool audio, sp&lt;DecoderBase&gt; *decoder, bool checkAudioModeChange) {
    ... ...
    if (!audio) {
        ... ...
    }
    ... ...
    if (audio) {
        sp&lt;AMessage&gt; notify = new AMessage(kWhatAudioNotify, this);
        ++mAudioDecoderGeneration;
        notify-&gt;setInt32(&quot;generation&quot;, mAudioDecoderGeneration);

        if (checkAudioModeChange) {
            determineAudioModeChange(format);
        }
        if (mOffloadAudio) {
            mSource-&gt;setOffloadAudio(true /* offload */);
            ... ...
            *decoder = new DecoderPassThrough(notify, mSource, mRenderer);
            ALOGV(&quot;instantiateDecoder audio DecoderPassThrough  hasVideo: %d&quot;, hasVideo);
        } else {
            mSource-&gt;setOffloadAudio(false /* offload */);
            *decoder = new Decoder(notify, mSource, mPID, mUID, mRenderer);
            ALOGV(&quot;instantiateDecoder audio Decoder&quot;);
        }
        mAudioDecoderError = false;
    } else {
        ... ...
    }
    (*decoder)-&gt;init();
    ... ...
    (*decoder)-&gt;configure(format);
    ... ...
}
</div></code></pre>
<h3 id="%E8%A7%A3%E7%A0%81%E5%99%A8nuplayerdecoder%E7%9A%84%E6%9E%84%E9%80%A0">解码器<code>NuPlayer::Decoder</code>的构造</h3>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
NuPlayer::Decoder::Decoder(
        const sp&lt;AMessage&gt; &amp;notify,
        const sp&lt;Source&gt; &amp;source,
        pid_t pid,
        uid_t uid,
        const sp&lt;Renderer&gt; &amp;renderer,
        const sp&lt;Surface&gt; &amp;surface,
        const sp&lt;CCDecoder&gt; &amp;ccDecoder)
    : DecoderBase(notify),
      mSurface(surface),
      mSource(source),
      mRenderer(renderer),
      mCCDecoder(ccDecoder),
      ... ...
      mComponentName(&quot;decoder&quot;) {
    mCodecLooper = new ALooper;
    mCodecLooper-&gt;setName(&quot;NPDecoder-CL&quot;);
    mCodecLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO);
    mVideoTemporalLayerAggregateFps[0] = mFrameRateTotal;
}

// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoderBase.cpp
NuPlayer::DecoderBase::DecoderBase(const sp&lt;AMessage&gt; &amp;notify)
    :  mNotify(notify),
       ... ...
       mRequestInputBuffersPending(false) {
    mDecoderLooper = new ALooper;
    mDecoderLooper-&gt;setName(&quot;NPDecoder&quot;);
    mDecoderLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO);
}
</div></code></pre>
<h3 id="%E8%A7%A3%E7%A0%81%E5%99%A8nuplayerdecoder%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">解码器<code>NuPlayer::Decoder</code>的初始化</h3>
<p><code>NuPlayer::instantiateDecoder()</code>中, <code>(*decoder)-&gt;init()</code>负责初始化解码器:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoderBase.cpp
void NuPlayer::DecoderBase::init() {
    mDecoderLooper-&gt;registerHandler(this);
}
</div></code></pre>
<h3 id="nuplayerdecoderonconfigure"><code>NuPlayer::Decoder::onConfigure()</code></h3>
<p><code>NuPlayer::instantiateDecoder()</code>中, <code>(*decoder)-&gt;configure(format)</code>开始配置解码器:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoderBase.cpp
void NuPlayer::DecoderBase::configure(const sp&lt;AMessage&gt; &amp;format) {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatConfigure, this);
    msg-&gt;setMessage(&quot;format&quot;, format);
    msg-&gt;post();
}

void NuPlayer::DecoderBase::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {

    switch (msg-&gt;what()) {
        case kWhatConfigure:
        {
            sp&lt;AMessage&gt; format;
            CHECK(msg-&gt;findMessage(&quot;format&quot;, &amp;format));
            onConfigure(format);
            break;
        }
        ... ...
    }
}
</div></code></pre>
<h4 id="mediacodeccreatebytype"><code>MediaCodec::CreateByType()</code></h4>
<p><code>onConfigure()</code>调用回子类<code>NuPlayer::Decoder::onConfigure()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
void NuPlayer::Decoder::onConfigure(const sp&lt;AMessage&gt; &amp;format) {
    ... ...
    mCodec = MediaCodec::CreateByType(
            mCodecLooper, mime.c_str(), false /* encoder */, NULL /* err */, mPid, mUid, format);
    int32_t secure = 0;
    if (format-&gt;findInt32(&quot;secure&quot;, &amp;secure) &amp;&amp; secure != 0) {
        ... ...
    }
    ... ...
    err = mCodec-&gt;configure(
            format, mSurface, crypto, 0 /* flags */);
    ... ...
    sp&lt;AMessage&gt; reply = new AMessage(kWhatCodecNotify, this);
    mCodec-&gt;setCallback(reply);
    ... ...
    err = mCodec-&gt;start();
    ... ...
}
</div></code></pre>
<p><code>NuPlayer::Decoder::onConfigure()</code>中<code>MediaCodec::CreateByType()</code>负责创建<code>MediaCodec</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
sp&lt;MediaCodec&gt; MediaCodec::CreateByType(
        const sp&lt;ALooper&gt; &amp;looper, const AString &amp;mime, bool encoder, status_t *err, pid_t pid,
        uid_t uid) {
    sp&lt;AMessage&gt; format;
    return CreateByType(looper, mime, encoder, err, pid, uid, format);
}
</div></code></pre>
<h5 id="mediacodecmediacodec-mediacodec%E7%8A%B6%E6%80%81-uninitialized"><code>MediaCodec::MediaCodec()</code>, <code>MediaCodec</code>状态: <code>UNINITIALIZED</code></h5>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
sp&lt;MediaCodec&gt; MediaCodec::CreateByType(
        const sp&lt;ALooper&gt; &amp;looper, const AString &amp;mime, bool encoder, status_t *err, pid_t pid,
        uid_t uid, sp&lt;AMessage&gt; format) {
    Vector&lt;AString&gt; matchingCodecs;

    MediaCodecList::findMatchingCodecs(
            mime.c_str(),
            encoder,
            0,
            format,
            &amp;matchingCodecs);
    ... ...
    for (size_t i = 0; i &lt; matchingCodecs.size(); ++i) {
        sp&lt;MediaCodec&gt; codec = new MediaCodec(looper, pid, uid);
        AString componentName = matchingCodecs[i];
        status_t ret = codec-&gt;init(componentName);
        ... ..
        if (ret == OK) {
            return codec;
        }
    }
    return NULL;
}
</div></code></pre>
<p><code>MediaCodecList::findMatchingCodecs()</code>负责查找支持当前解码格式解码器的名字, 其定义在<code>MediaCodecList.cpp</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodecList.cpp
void MediaCodecList::findMatchingCodecs(
        const char *mime, bool encoder, uint32_t flags,
        Vector&lt;AString&gt; *matches) {
    sp&lt;AMessage&gt; format;        // initializes as clear/null
    findMatchingCodecs(mime, encoder, flags, format, matches);
}

void MediaCodecList::findMatchingCodecs(
        const char *mime, bool encoder, uint32_t flags, sp&lt;AMessage&gt; format,
        Vector&lt;AString&gt; *matches) {
    matches-&gt;clear();
    const sp&lt;IMediaCodecList&gt; list = getInstance();
    ... ...
    size_t index = 0;
    for (;;) {
        ssize_t matchIndex =
            list-&gt;findCodecByType(mime, encoder, index);
        if (matchIndex &lt; 0) {
            break;
        }
        index = matchIndex + 1;
        const sp&lt;MediaCodecInfo&gt; info = list-&gt;getCodecInfo(matchIndex);
        CHECK(info != nullptr);
        AString componentName = info-&gt;getCodecName();
        ... ...
        matches-&gt;push(componentName);
        ALOGV(&quot;matching '%s'&quot;, componentName.c_str());
    }

    if (flags &amp; kPreferSoftwareCodecs ||
            property_get_bool(&quot;debug.stagefright.swcodec&quot;, false)) {
        matches-&gt;sort(compareSoftwareCodecsFirst);
    }
}
</div></code></pre>
<p>此时如果找到解码器, 回到<code>MediaCodec::CreateByType()</code>, 开始创建<code>MediaCodec</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
MediaCodec::MediaCodec(
        const sp&lt;ALooper&gt; &amp;looper, pid_t pid, uid_t uid,
        std::function&lt;sp&lt;CodecBase&gt;(const AString &amp;, const char *)&gt; getCodecBase,
        std::function&lt;status_t(const AString &amp;, sp&lt;MediaCodecInfo&gt; *)&gt; getCodecInfo)
    : mState(UNINITIALIZED),
      ... ...
      mGetCodecInfo(getCodecInfo) {
    ... ...
    mResourceManagerProxy = new ResourceManagerServiceProxy(pid, mUid,
            ::ndk::SharedRefBase::make&lt;ResourceManagerClient&gt;(this));
    if (!mGetCodecBase) {
        mGetCodecBase = [](const AString &amp;name, const char *owner) {
            return GetCodecBase(name, owner);
        };
    }
    ... ...
    initMediametrics();
}
</div></code></pre>
<p><code>mGetCodecBase</code>被初始化为一个<code>std::function&lt;&gt;</code>对象, 后文的<code>MediaCodec::init()</code>会调用此<code>lambada</code>.</p>
<h5 id="mediacodecinit-mediacodec%E7%8A%B6%E6%80%81-uninitialized---initializing---initialized"><code>MediaCodec::init()</code>, <code>MediaCodec</code>状态: <code>UNINITIALIZED</code> -&gt; <code>INITIALIZING</code> -&gt; <code>INITIALIZED</code></h5>
<p>回到<code>MediaCodec::CreateByType()</code>中, <code>MediaCodec</code>创建完成后通过<code>init()</code>配置通过<code>MediaCodecList::findMatchingCodecs()</code>找到的解码器:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
status_t MediaCodec::init(const AString &amp;name) {
    .... ...
    mCodec = mGetCodecBase(name, owner);
    ... ...
    mCodec-&gt;setCallback(
            std::unique_ptr&lt;CodecBase::CodecCallback&gt;(
                    new CodecCallback(new AMessage(kWhatCodecNotify, this))));
    mBufferChannel = mCodec-&gt;getBufferChannel();
    mBufferChannel-&gt;setCallback(
            std::unique_ptr&lt;CodecBase::BufferCallback&gt;(
                    new BufferCallback(new AMessage(kWhatCodecNotify, this))));
    sp&lt;AMessage&gt; msg = new AMessage(kWhatInit, this);
    ... ...
    for (int i = 0; i &lt;= kMaxRetry; ++i) {
        ... ...
        err = PostAndAwaitResponse(msg, &amp;response);
        ... ...
    }
    ... ...
</div></code></pre>
<h6 id="ccodec%E7%9A%84%E6%9E%84%E9%80%A0"><code>CCodec</code>的构造</h6>
<p><code>mGetCodecBase</code>上文已介绍过, 故:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
//static
sp&lt;CodecBase&gt; MediaCodec::GetCodecBase(const AString &amp;name, const char *owner) {
    if (owner) {
        if (strcmp(owner, &quot;default&quot;) == 0) {
            return new ACodec;
        } else if (strncmp(owner, &quot;codec2&quot;, 6) == 0) {
            return CreateCCodec();
        }
    }
    if (name.startsWithIgnoreCase(&quot;c2.&quot;)) {
        return CreateCCodec();
    } else ... ...
}

static CodecBase *CreateCCodec() {
    return new CCodec;
}
</div></code></pre>
<p>有着一些列的判断, Android S现在已普遍采用<code>Codec2</code>的框架, 因此, 因此通过<code>CreateCCodec()</code>创建了<code>CCodec</code>.</p>
<h6 id="ccodecsetcallback%E9%85%8D%E7%BD%AE%E8%A7%A3%E7%A0%81%E5%99%A8%E5%9B%9E%E8%B0%83"><code>CCodec::setCallback()</code>配置解码器回调</h6>
<p>回到<code>MediaCodec::init()</code>, 首先构造了<code>CodecCallback</code>, 其实现了<code>CodecBase::CodecCallback</code>接口, 而<code>CCodec::setCallback()</code>是在父类<code>CodecBase</code>实现的:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/include/media/stagefright/CodecBase.h
struct CodecBase : public AHandler, /* static */ ColorUtils {
    ... ...
    inline void setCallback(std::unique_ptr&lt;CodecCallback&gt; &amp;&amp;callback) {
        mCallback = std::move(callback);
    }
</div></code></pre>
<p>因此<code>MediaCodec::CodecCallback</code>作为<code>CodecBase::CodecCallback</code>设置在了<code>CCodec</code>的<code>mCallback</code>方法.</p>
<h6 id="ccodecbufferchannelsetcallback%E9%85%8D%E7%BD%AE%E8%A7%A3%E7%A0%81%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%E7%9A%84%E5%9B%9E%E8%B0%83"><code>CCodecBufferChannel::setCallback()</code>配置解码缓冲通道的回调</h6>
<p>回到<code>MediaCodec::init()</code>, 首先构造了<code>BufferCallback</code>, 其实现了<code>CodecBase::BufferCallback</code>接口, 而<code>mBufferChannel</code>的类型是<code>CCodecBufferChannel</code>, 其<code>setCallback()</code>是在父类``实现的:</p>
<pre class="hljs"><code><div>// prebuilts/vndk/v30/arm/include/frameworks/av/media/libstagefright/include/media/stagefright/CodecBase.h
class BufferChannelBase {
public:
    ... ...
    inline void setCallback(std::unique_ptr&lt;CodecBase::BufferCallback&gt; &amp;&amp;callback) {
        mCallback = std::move(callback);
    }
</div></code></pre>
<p>因此<code>MediaCodec::BufferCallback</code>作为<code>CodecBase::BufferCallback</code>设置在了<code>CCodecBufferChannel</code>的<code>mCallback</code>方法.</p>
<h6 id="ccodecinitiateallocatecomponent-mediacodec%E7%8A%B6%E6%80%81-uninitialized---initializing"><code>CCodec::initiateAllocateComponent()</code>, <code>MediaCodec</code>状态: <code>UNINITIALIZED</code> -&gt; <code>INITIALIZING</code></h6>
<p>回到<code>MediaCodec::init()</code>后期<code>kWhatInit</code>消息被发出, 其响应:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        ... ...
        case kWhatInit:
        {
            ... ...
            setState(INITIALIZING);
            ... ...
            mCodec-&gt;initiateAllocateComponent(format);
            break;
        }
        ... ...
    }
}
</div></code></pre>
<h6 id="ccodecinitiateallocatecomponent%E5%AE%8C%E6%88%90-mediacodec%E7%8A%B6%E6%80%81-initializing---initialized"><code>CCodec::initiateAllocateComponent()</code>完成, <code>MediaCodec</code>状态: <code>INITIALIZING</code> -&gt; <code>INITIALIZED</code></h6>
<p><code>mCodec</code>的类型是<code>CCodec</code>, 故:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodec.cpp
void CCodec::initiateAllocateComponent(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    sp&lt;AMessage&gt; allocMsg(new AMessage(kWhatAllocate, this));
    allocMsg-&gt;setObject(&quot;codecInfo&quot;, codecInfo);
    allocMsg-&gt;post();
}

void CCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    TimePoint now = std::chrono::steady_clock::now();
    CCodecWatchdog::getInstance()-&gt;watch(this);
    switch (msg-&gt;what()) {
        case kWhatAllocate: {
            ... ...
            allocate((MediaCodecInfo *)obj.get());
            break;
        }
        ... ...

void CCodec::allocate(const sp&lt;MediaCodecInfo&gt; &amp;codecInfo) {
    ... ...
    client = Codec2Client::CreateFromService(&quot;default&quot;);
    ... ...
    std::shared_ptr&lt;Codec2Client::Component&gt; comp;
    c2_status_t status = Codec2Client::CreateComponentByName(
            componentName.c_str(),
            mClientListener,
            &amp;comp,
            &amp;client);
    ... ...
    mChannel-&gt;setComponent(comp);
    ... ...
    mCallback-&gt;onComponentAllocated(componentName.c_str());
}
</div></code></pre>
<p><code>mCallback</code>的类型是<code>CodecCallback</code>, 此处调用到<code>CodecCallback::onComponentAllocated()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
void CodecCallback::onComponentAllocated(const char *componentName) {
    sp&lt;AMessage&gt; notify(mNotify-&gt;dup());
    notify-&gt;setInt32(&quot;what&quot;, kWhatComponentAllocated);
    notify-&gt;setString(&quot;componentName&quot;, componentName);
    notify-&gt;post();
}

void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        {
            ... ...
            switch (what) {
                case kWhatError:
                ... ...
                case kWhatComponentAllocated:
                {
                    ... ...
                    setState(INITIALIZED);
                    ... ...
                    postPendingRepliesAndDeferredMessages(&quot;kWhatComponentAllocated&quot;);
                    break;
                }
                ... ...
</div></code></pre>
<p>至此<code>MediaCodec::init()</code>算结束了.</p>
<h4 id="mediacodecconfigure-mediacodec%E7%8A%B6%E6%80%81-initialized---configuring"><code>MediaCodec::configure()</code>, <code>MediaCodec</code>状态: <code>INITIALIZED</code> -&gt; <code>CONFIGURING</code></h4>
<p>回到<code>NuPlayer::Decoder::onConfigure()</code>, 开始通过<code>mCodec-&gt;configure()</code>对<code>MediaCodec</code>进行配置:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
status_t MediaCodec::configure(
        const sp&lt;AMessage&gt; &amp;format,
        const sp&lt;Surface&gt; &amp;nativeWindow,
        const sp&lt;ICrypto&gt; &amp;crypto,
        uint32_t flags) {
    return configure(format, nativeWindow, crypto, NULL, flags);
}
status_t MediaCodec::configure(
        const sp&lt;AMessage&gt; &amp;format,
        const sp&lt;Surface&gt; &amp;surface,
        const sp&lt;ICrypto&gt; &amp;crypto,
        const sp&lt;IDescrambler&gt; &amp;descrambler,
        uint32_t flags) {
    ... ...
    sp&lt;AMessage&gt; msg = new AMessage(kWhatConfigure, this);
    updateLowLatency(format);
    msg-&gt;setMessage(&quot;format&quot;, format);
    msg-&gt;setInt32(&quot;flags&quot;, flags);
    msg-&gt;setObject(&quot;surface&quot;, surface);
    mConfigureMsg = msg;
    for (int i = 0; i &lt;= kMaxRetry; ++i) {
        sp&lt;AMessage&gt; response;
        err = PostAndAwaitResponse(msg, &amp;response);
        ... ...

void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        ... ...
        case kWhatConfigure:
        {
            ... ...
            mReplyID = replyID;
            setState(CONFIGURING);
            .. ...
            mCodec-&gt;initiateConfigureComponent(format);
            break;
        }
    ... ...
</div></code></pre>
<p><code>PostAndAwaitResponse()</code>会等待<code>MediaCodec::onMessageReceived()</code>处理完成的消息回复, 后者通过<code>mReplyID</code>记录了回复的ID. 后问有用到.</p>
<h5 id="ccodecinitiateconfigurecomponent-mediacodec%E7%8A%B6%E6%80%81-configuring---configured"><code>CCodec::initiateConfigureComponent()</code>, <code>MediaCodec</code>状态: <code>CONFIGURING</code> -&gt; <code>CONFIGURED</code></h5>
<p><code>mCodec</code>的类型是<code>CCodec</code>, 因此:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodec.cpp
void CCodec::initiateConfigureComponent(const sp&lt;AMessage&gt; &amp;format) {
    ... ...
    sp&lt;AMessage&gt; msg(new AMessage(kWhatConfigure, this));
    msg-&gt;setMessage(&quot;format&quot;, format);
    msg-&gt;post();
}

void CCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    switch (msg-&gt;what()) {
        ... ...
        case kWhatConfigure: {
            // C2Component::commit_sm() should return within 5ms.
            setDeadline(now, 1500ms, &quot;configure&quot;);
            sp&lt;AMessage&gt; format;
            CHECK(msg-&gt;findMessage(&quot;format&quot;, &amp;format));
            configure(format);
            break;
        }
        ... ...

void CCodec::configure(const sp&lt;AMessage&gt; &amp;msg) {
    std::shared_ptr&lt;Codec2Client::Component&gt; comp;
    auto checkAllocated = [this, &amp;comp] {
        ... ...
    }
    if (tryAndReportOnError(checkAllocated) != OK) {
        return;
    }
    auto doConfig = [msg, comp, this]() -&gt; status_t {
        AString mime;
        ... ...
    }
    if (tryAndReportOnError(doConfig) != OK) {
        return;
    }
    Mutexed&lt;std::unique_ptr&lt;Config&gt;&gt;::Locked configLocked(mConfig);
    const std::unique_ptr&lt;Config&gt; &amp;config = *configLocked;
    config-&gt;queryConfiguration(comp);
    mCallback-&gt;onComponentConfigured(config-&gt;mInputFormat, config-&gt;mOutputFormat);
}
</div></code></pre>
<p><code>doConfig</code>是个<code>lambada</code>, 作为<code>std::fucntion</code>传递给<code>tryAndReportOnError()</code>, 该部分代码做了大量配置工作, 完成配置后, <code>mCallback-&gt;onComponentConfigured()</code>回调到上文设置的<code>MediaCodec::CodecCallback::onComponentConfigured()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
void CodecCallback::onComponentConfigured(
        const sp&lt;AMessage&gt; &amp;inputFormat, const sp&lt;AMessage&gt; &amp;outputFormat) {
    ... ...
    notify-&gt;setInt32(&quot;what&quot;, kWhatComponentConfigured);
    ... ...
    notify-&gt;post();
}
void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        {
            ... ...
            switch (what) {
                case kWhatError:
                ... ....
                case kWhatComponentConfigured:
                {
                    ... ...
                    setState(CONFIGURED);
                    postPendingRepliesAndDeferredMessages(&quot;kWhatComponentConfigured&quot;);
                    ... ...

void MediaCodec::postPendingRepliesAndDeferredMessages(
        std::string origin, status_t err /* = OK */) {
    ... ...
    postPendingRepliesAndDeferredMessages(origin, response);
}

void MediaCodec::postPendingRepliesAndDeferredMessages(
        std::string origin, const sp&lt;AMessage&gt; &amp;response) {
    LOG_ALWAYS_FATAL_IF(
            !mReplyID,
            &quot;postPendingRepliesAndDeferredMessages: mReplyID == null, from %s following %s&quot;,
            origin.c_str(),
            mLastReplyOrigin.c_str());
    mLastReplyOrigin = origin;
    response-&gt;postReply(mReplyID);
    ... ...
}
</div></code></pre>
<p>此时上文的<code>PostAndAwaitResponse()</code>返回, <code>MediaCodec::configure()</code>结束.</p>
<h4 id="mediacodecstart-mediacodec%E7%8A%B6%E6%80%81-configured---starting"><code>MediaCodec::start()</code>, <code>MediaCodec</code>状态: <code>CONFIGURED</code> -&gt; <code>STARTING</code></h4>
<p>回到<code>NuPlayer::Decoder::onConfigure()</code>中, 此时调用到<code>mCodec-&gt;start()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
status_t MediaCodec::start() {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatStart, this);
    ... ...
    for (int i = 0; i &lt;= kMaxRetry; ++i) {
        ... ...
        err = PostAndAwaitResponse(msg, &amp;response);
        ... ...
    }
    ... ...
}

void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        ... ...
        case kWhatStart:
        {
            ... ...
            mReplyID = replyID;
            setState(STARTING);
            mCodec-&gt;initiateStart();
            break;
        }
        ... ...
</div></code></pre>
<h5 id="ccodecinitiatestart-mediacodec%E7%8A%B6%E6%80%81-starting---started"><code>CCodec::initiateStart()</code>, <code>MediaCodec</code>状态: <code>STARTING</code> -&gt; <code>STARTED</code></h5>
<p><code>PostAndAwaitResponse()</code>和上文的流程基本相同, 仅关注主要的流程<code>CCodec::initiateStart()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodec.cpp
void CCodec::initiateStart() {
    auto setStarting = [this] {
        Mutexed&lt;State&gt;::Locked state(mState);
        if (state-&gt;get() != ALLOCATED) {
            return UNKNOWN_ERROR;
        }
        state-&gt;set(STARTING);
        return OK;
    };
    if (tryAndReportOnError(setStarting) != OK) {
        return;
    }
    (new AMessage(kWhatStart, this))-&gt;post();
}
</div></code></pre>
<h5 id="ccodecstart"><code>CCodec::start()</code></h5>
<p><code>kWhatStart</code>消息由<code>CCodec::onMessageReceived()</code>处理:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodec.cpp
void CCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    TimePoint now = std::chrono::steady_clock::now();
    CCodecWatchdog::getInstance()-&gt;watch(this);
    switch (msg-&gt;what()) {
        case kWhatAllocate: 
        ... ...
        case kWhatStart: {
            // C2Component::start() should return within 500ms.
            setDeadline(now, 1500ms, &quot;start&quot;);
            start();
            break;
        }
        ... ...
    }
    setDeadline(TimePoint::max(), 0ms, &quot;none&quot;);
}

void CCodec::start() {
    ... ...
    c2_status_t err = comp-&gt;start();
    ... ...
    err2 = mChannel-&gt;start(inputFormat, outputFormat, buffersBoundToCodec);
    ... ...
    mCallback-&gt;onStartCompleted();
    (void)mChannel-&gt;requestInitialInputBuffers();
}
</div></code></pre>
<h5 id="ccodecbufferchannelstart%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97igraphicbufferproducer%E7%9A%84%E9%85%8D%E7%BD%AE"><code>CCodecBufferChannel::start()</code>对视频输出缓冲队列<code>IGraphicBufferProducer</code>的配置</h5>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodecBufferChannel.cpp
status_t CCodecBufferChannel::start(
        const sp&lt;AMessage&gt; &amp;inputFormat,
        const sp&lt;AMessage&gt; &amp;outputFormat,
        bool buffersBoundToCodec) {
    ... ...
    if (outputFormat != nullptr) {
        ... ...
        // Try to set output surface to created block pool if given.
        if (outputSurface) {
            mComponent-&gt;setOutputSurface(
                    outputPoolId_,
                    outputSurface,
                    outputGeneration,
                    maxDequeueCount);
        } else ... ...
        ... ...
    }
    ... ...
    mInputMetEos = false;
    mSync.start();
    return OK;
}
</div></code></pre>
<p>继续对<code>mComponent</code>也就是``进行配置:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/client.cpp
c2_status_t Codec2Client::Component::setOutputSurface(
        C2BlockPool::local_id_t blockPoolId,
        const sp&lt;IGraphicBufferProducer&gt;&amp; surface,
        uint32_t generation,
        int maxDequeueCount) {
    ... ...
    if (!surface) {
        mOutputBufferQueue-&gt;configure(nullIgbp, generation, 0, maxDequeueCount, nullptr);
    } else if (surface-&gt;getUniqueId(&amp;bqId) != OK) {
        ... ...
        mOutputBufferQueue-&gt;configure(nullIgbp, generation, 0, maxDequeueCount, nullptr);
    } else {
        mOutputBufferQueue-&gt;configure(surface, generation, bqId, maxDequeueCount, mBase1_2 ?
                                      &amp;syncObj : nullptr);
    }
    ... ...
}
</div></code></pre>
<p><code>mOutputBufferQueue</code>的类型是<code>OutputBufferQueue</code>, 因此不管那个分支, 都调用了<code>OutputBufferQueue::configure()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/output.cpp
bool OutputBufferQueue::configure(const sp&lt;IGraphicBufferProducer&gt;&amp; igbp,
                                  uint32_t generation,
                                  uint64_t bqId,
                                  int maxDequeueBufferCount,
                                  std::shared_ptr&lt;V1_2::SurfaceSyncObj&gt; *syncObj) {
    ... ...
    sp&lt;GraphicBuffer&gt; buffers[BufferQueueDefs::NUM_BUFFER_SLOTS];
    std::weak_ptr&lt;_C2BlockPoolData&gt;
            poolDatas[BufferQueueDefs::NUM_BUFFER_SLOTS];
    {
        ... ...
        mIgbp = igbp;
        ... ...
        for (int i = 0; i &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; ++i) {
            ... ...
            status_t result = igbp-&gt;attachBuffer(&amp;bqSlot, mBuffers[i]);
            if (result != OK) {
                continue;
            }
            bool attach =
                    _C2BlockFactory::EndAttachBlockToBufferQueue(
                            data, mOwner, getHgbp(mIgbp), mSyncMem,
                            generation, bqId, bqSlot);
            ... ...
        }
        ... ...
    }
    ... ...
}
</div></code></pre>
<p><code>IGraphicBufferProducer</code>被设置到了<code>OutputBufferQueue</code>的<code>mIgbp</code>, 在后文<code>OutputBufferQueue::outputBuffer()</code>时会用到</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
void CodecCallback::onStartCompleted() {
    sp&lt;AMessage&gt; notify(mNotify-&gt;dup());
    notify-&gt;setInt32(&quot;what&quot;, kWhatStartCompleted);
    notify-&gt;post();
}

void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        {
            ... ...
            switch (what) {
                case kWhatError:
                ... ...
                case kWhatStartCompleted:
                {
                    ... ...
                    if (mIsVideo) {
                        mResourceManagerProxy-&gt;addResource(
                                MediaResource::GraphicMemoryResource(getGraphicBufferSize()));
                    }
                    setState(STARTED);
                    postPendingRepliesAndDeferredMessages(&quot;kWhatStartCompleted&quot;);
                    break;
                }
</div></code></pre>
<p><code>postPendingRepliesAndDeferredMessages(&quot;kWhatStartCompleted&quot;)</code>完成后, <code>MediaCodec::start()</code>返回.</p>
<h1 id="%E6%9D%A5%E8%87%AAcodec2%E7%9A%84hidllisteneronworkdone">来自<code>Codec2</code>的<code>HidlListener::onWorkDone()</code></h1>
<p><code>Codec2</code>组建<code>Component</code>通过<code>IHwComponentListener</code>也就是<code>BnHwComponentListener::_hidl_onWorkDone()</code>接口通知<code>mediaserver</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/client.cpp
struct Codec2Client::Component::HidlListener : public IComponentListener {
    std::weak_ptr&lt;Component&gt; component;
    std::weak_ptr&lt;Listener&gt; base;

    virtual Return&lt;void&gt; onWorkDone(const WorkBundle&amp; workBundle) override {
        ... ...
        if (!objcpy(&amp;workItems, workBundle)) {
            LOG(DEBUG) &lt;&lt; &quot;onWorkDone -- received corrupted WorkBundle.&quot;;
            return Void();
        }
        // release input buffers potentially held by the component from queue
        std::shared_ptr&lt;Codec2Client::Component&gt; strongComponent =
                component.lock();
        if (strongComponent) {
            strongComponent-&gt;handleOnWorkDone(workItems);
        }
        if (std::shared_ptr&lt;Codec2Client::Listener&gt; listener = base.lock()) {
            listener-&gt;onWorkDone(component, workItems);
        } else ... ...
    }
</div></code></pre>
<h2 id="objcpy%E5%AE%8C%E6%88%90framedata---c2framedata%E8%BD%AC%E6%8D%A2"><code>objcpy()</code>完成<code>FrameData</code> -&gt; <code>C2FrameData</code>转换</h2>
<p><code>objcpy()</code>是个非常重要的操作:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/1.0/utils/types.cpp
// WorkBundle -&gt; std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt;
bool objcpy(std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt;* d, const WorkBundle&amp; s) {
    // Convert BaseBlocks to C2BaseBlocks.
    std::vector&lt;C2BaseBlock&gt; dBaseBlocks(s.baseBlocks.size());
    for (size_t i = 0; i &lt; s.baseBlocks.size(); ++i) {
        if (!objcpy(&amp;dBaseBlocks[i], s.baseBlocks[i])) {
            LOG(ERROR) &lt;&lt; &quot;Invalid WorkBundle::baseBlocks[&quot;
                       &lt;&lt; i &lt;&lt; &quot;].&quot;;
            return false;
        }
    }

    d-&gt;clear();
    for (const Work&amp; sWork : s.works) {
        d-&gt;emplace_back(std::make_unique&lt;C2Work&gt;());
        C2Work&amp; dWork = *d-&gt;back();

        // chain info is not in use currently.

        // input
        if (!objcpy(&amp;dWork.input, sWork.input, dBaseBlocks)) {
            LOG(ERROR) &lt;&lt; &quot;Invalid Work::input.&quot;;
            return false;
        }

        // worklet(s)
        dWork.worklets.clear();
        for (const Worklet&amp; sWorklet : sWork.worklets) {
            std::unique_ptr&lt;C2Worklet&gt; dWorklet = std::make_unique&lt;C2Worklet&gt;();
            ... ...
            // output
            if (!objcpy(&amp;dWorklet-&gt;output, sWorklet.output, dBaseBlocks)) {
                LOG(ERROR) &lt;&lt; &quot;Invalid Worklet::output.&quot;;
                return false;
            }

            dWork.worklets.emplace_back(std::move(dWorklet));
        }

        // workletsProcessed
        dWork.workletsProcessed = sWork.workletsProcessed;

        // result
        dWork.result = static_cast&lt;c2_status_t&gt;(sWork.result);
    }

    return true;
}
</div></code></pre>
<p>对于<code>objcpy(&amp;dBaseBlocks[i], s.baseBlocks[i])</code>:</p>
<pre class="hljs"><code><div>bool objcpy(C2BaseBlock* d, const BaseBlock&amp; s) {
    switch (s.getDiscriminator()) {
    case BaseBlock::hidl_discriminator::nativeBlock: {
            native_handle_t* sHandle =
                    native_handle_clone(s.nativeBlock());
            ... ...
            const C2Handle *sC2Handle =
                    reinterpret_cast&lt;const C2Handle*&gt;(sHandle);

            d-&gt;linear = _C2BlockFactory::CreateLinearBlock(sC2Handle);
            ... ...
            d-&gt;graphic = _C2BlockFactory::CreateGraphicBlock(sC2Handle);
            ... ...
        }
        ... ...
</div></code></pre>
<p>对于<code>_C2BlockFactory::CreateGraphicBlock()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/vndk/platform/C2BqBuffer.cpp
std::shared_ptr&lt;C2GraphicBlock&gt; _C2BlockFactory::CreateGraphicBlock(
        const C2Handle *handle) {
    // TODO: get proper allocator? and mutex?
    static std::unique_ptr&lt;C2AllocatorGralloc&gt; sAllocator = std::make_unique&lt;C2AllocatorGralloc&gt;(0);

    std::shared_ptr&lt;C2GraphicAllocation&gt; alloc;
    if (C2AllocatorGralloc::CheckHandle(handle)) {
        ... ...
        android::_UnwrapNativeCodec2GrallocMetadata(
                handle, &amp;width, &amp;height, &amp;format, &amp;usage, &amp;stride, &amp;generation, &amp;bqId, &amp;bqSlot);
        c2_status_t err = sAllocator-&gt;priorGraphicAllocation(handle, &amp;alloc);
        if (err == C2_OK) {
            std::shared_ptr&lt;C2GraphicBlock&gt; block;
            if (bqId || bqSlot) {
                // BQBBP
                std::shared_ptr&lt;C2BufferQueueBlockPoolData&gt; poolData =
                        std::make_shared&lt;C2BufferQueueBlockPoolData&gt;(generation,
                                                                     bqId,
                                                                     (int32_t)bqSlot,
                                                                     nullptr,
                                                                     nullptr);
                block = _C2BlockFactory::CreateGraphicBlock(alloc, poolData);
            } else ... ...
            return block;
        }
    }
    return nullptr;
}

// frameworks/av/media/codec2/vndk/C2Buffer.cpp
std::shared_ptr&lt;C2GraphicBlock&gt; _C2BlockFactory::CreateGraphicBlock(
        const std::shared_ptr&lt;C2GraphicAllocation&gt; &amp;alloc,
        const std::shared_ptr&lt;_C2BlockPoolData&gt; &amp;data, const C2Rect &amp;allottedCrop) {
    std::shared_ptr&lt;C2Block2D::Impl&gt; impl =
        std::make_shared&lt;C2Block2D::Impl&gt;(alloc, data, allottedCrop);
    return std::shared_ptr&lt;C2GraphicBlock&gt;(new C2GraphicBlock(impl, *impl));
}
</div></code></pre>
<p>此时<code>C2GraphicBlock</code>被创建, 并配置给了<code>dBaseBlocks[i]</code>(类型为<code>C2BaseBlock</code>)的<code>graphic</code>成员.
回到<code>bool objcpy(std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt;* d, const WorkBundle&amp; s)</code>, 对于<code>objcpy(&amp;dWorklet-&gt;output, sWorklet.output, dBaseBlocks)</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/1.0/utils/types.cpp
// FrameData -&gt; C2FrameData
bool objcpy(C2FrameData* d, const FrameData&amp; s,
        const std::vector&lt;C2BaseBlock&gt;&amp; baseBlocks) {
    ... ...
    if (!objcpy(&amp;d-&gt;ordinal, s.ordinal)) {
        LOG(ERROR) &lt;&lt; &quot;Invalid FrameData::ordinal.&quot;;
        return false;
    }
    d-&gt;buffers.clear();
    d-&gt;buffers.reserve(s.buffers.size());
    for (const Buffer&amp; sBuffer : s.buffers) {
        std::shared_ptr&lt;C2Buffer&gt; dBuffer;
        if (!objcpy(&amp;dBuffer, sBuffer, baseBlocks)) {
            LOG(ERROR) &lt;&lt; &quot;Invalid FrameData::buffers.&quot;;
            return false;
        }
        d-&gt;buffers.emplace_back(dBuffer);
    }
    ... ...
</div></code></pre>
<p>对于<code>objcpy(&amp;d-&gt;ordinal, s.ordinal)</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/1.0/utils/types.cpp
bool objcpy(C2WorkOrdinalStruct *d, const WorkOrdinal &amp;s) {
    d-&gt;frameIndex = c2_cntr64_t(s.frameIndex);
    d-&gt;timestamp = c2_cntr64_t(s.timestampUs);
    d-&gt;customOrdinal = c2_cntr64_t(s.customOrdinal);
    return true;
}
</div></code></pre>
<p>而对于<code>objcpy(&amp;dBuffer, sBuffer, baseBlocks)</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/1.0/utils/types.cpp
// Buffer -&gt; C2Buffer
// Note: The native handles will be cloned.
bool objcpy(std::shared_ptr&lt;C2Buffer&gt;* d, const Buffer&amp; s,
        const std::vector&lt;C2BaseBlock&gt;&amp; baseBlocks) {
    *d = nullptr;
    ... ...
    // Construct a block.
    switch (baseBlock.type) {
    case C2BaseBlock::LINEAR:
        ... ...
    case C2BaseBlock::GRAPHIC:
        if (!createGraphicBuffer(d, baseBlock.graphic, sBlockMeta, dFence)) {
            LOG(ERROR) &lt;&lt; &quot;Invalid C2BaseBlock::graphic.&quot;;
            return false;
        }
        break;
    ... ...
    }
    ... ...
    for (C2Param* param : params) {
        ... ...
        c2_status_t status =
                (*d)-&gt;setInfo(std::static_pointer_cast&lt;C2Info&gt;(c2param));
        ... ...
    }

    return true;
}
</div></code></pre>
<p>综上<code>objcopy()</code>完成以下几项工作:</p>
<ul>
<li>将<code>WorkBundle</code>转化为<code>C2GraphicBlock</code></li>
<li>根据<code>C2GraphicBlock</code>, 完成<code>FrameData</code> -&gt; <code>C2FrameData</code>
<ul>
<li>循环完成<code>Buffer</code> -&gt; <code>C2Buffer</code>的转换</li>
</ul>
</li>
</ul>
<p>至此<code>C2FrameData</code>构造完成并置换至<code>C2Work::worklets::output</code>中.</p>
<h2 id="holdbufferqueueblocks%E5%AE%8C%E6%88%90c2constgraphicblock---graphicbuffer%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%BC%93%E5%AD%98%E5%AF%BC%E5%85%A5"><code>holdBufferQueueBlocks()</code>完成<code>C2ConstGraphicBlock</code> -&gt; <code>GraphicBuffer</code>的图形缓存导入</h2>
<p>回到<code>HidlListener::onWorkDone()</code>的<code>strongComponent-&gt;handleOnWorkDone()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/client.cpp
void Codec2Client::Component::handleOnWorkDone(
        const std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt; &amp;workItems) {
    // Output bufferqueue-based blocks' lifetime management
    mOutputBufferQueue-&gt;holdBufferQueueBlocks(workItems);
}
</div></code></pre>
<p><code>mOutputBufferQueue</code>类型为<code>OutputBufferQueue</code>, 故:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/output.cpp
void OutputBufferQueue::holdBufferQueueBlocks(
        const std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt;&amp; workList) {
    forEachBlock(workList,
                 std::bind(&amp;OutputBufferQueue::registerBuffer,
                           this, std::placeholders::_1));
}
</div></code></pre>
<p>对于<code>forEachBlock()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/1.0/utils/types.cpp
void forEachBlock(const std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt;&amp; workList,
                  BlockProcessor process,
                  bool processInput, bool processOutput) {
    for (const std::unique_ptr&lt;C2Work&gt;&amp; work : workList) {
        if (!work) {
            continue;
        }
        if (processInput) {
            forEachBlock(work-&gt;input, process);
        }
        if (processOutput) {
            for (const std::unique_ptr&lt;C2Worklet&gt;&amp; worklet : work-&gt;worklets) {
                if (worklet) {
                    forEachBlock(worklet-&gt;output,
                                 process);
                }
            }
        }
    }
}

template &lt;typename BlockProcessor&gt;
void forEachBlock(C2FrameData&amp; frameData,
                  BlockProcessor process) {
    for (const std::shared_ptr&lt;C2Buffer&gt;&amp; buffer : frameData.buffers) {
        if (buffer) {
            for (const C2ConstGraphicBlock&amp; block :
                    buffer-&gt;data().graphicBlocks()) {
                process(block);
            }
        }
    }
}
</div></code></pre>
<p><code>process</code>正是上文代码中的<code>std::bind(&amp;OutputBufferQueue::registerBuffer, this, std::placeholders::_1));</code>, 这相当与<code>OutputBufferQueue::registerBuffer()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/output.cpp
bool OutputBufferQueue::registerBuffer(const C2ConstGraphicBlock&amp; block) {
    std::shared_ptr&lt;_C2BlockPoolData&gt; data =
            _C2BlockFactory::GetGraphicBlockPoolData(block);
    ... ...
    // If the block is not bufferqueue-based, do nothing.
    if (!_C2BlockFactory::GetBufferQueueData(
            data, &amp;oldGeneration, &amp;oldId, &amp;oldSlot) || (oldId == 0)) {
        return false;
    }
    ... ...
    // If the block's bqId is the same as the desired bqId, just hold.
    if ((oldId == mBqId) &amp;&amp; (oldGeneration == mGeneration)) {
        ... ...
        _C2BlockFactory::HoldBlockFromBufferQueue(data, mOwner, getHgbp(mIgbp), mSyncMem);
        mPoolDatas[oldSlot] = data;
        mBuffers[oldSlot] = createGraphicBuffer(block);
        mBuffers[oldSlot]-&gt;setGenerationNumber(mGeneration);
        return true;
    }
    ... ...
}

// Create a GraphicBuffer object from a graphic block.
sp&lt;GraphicBuffer&gt; createGraphicBuffer(const C2ConstGraphicBlock&amp; block) {
    ... ....
    _UnwrapNativeCodec2GrallocMetadata(
            block.handle(), &amp;width, &amp;height, &amp;format, &amp;usage,
            &amp;stride, &amp;generation, &amp;bqId, reinterpret_cast&lt;uint32_t*&gt;(&amp;bqSlot));
    native_handle_t *grallocHandle =
            UnwrapNativeCodec2GrallocHandle(block.handle());
    sp&lt;GraphicBuffer&gt; graphicBuffer =
            new GraphicBuffer(grallocHandle,
                              GraphicBuffer::CLONE_HANDLE,
                              width, height, format,
                              1, usage, stride);
    native_handle_delete(grallocHandle);
    return graphicBuffer;
}
</div></code></pre>
<p><code>createGraphicBuffer()</code>负责从<code>C2ConstGraphicBlock</code>到<code>GraphicBuffer</code>的转化(导入), 并保存到<code>OutputBufferQueue</code>的<code>mBuffers[oldSlot]</code>. 而<code>C2ConstGraphicBlock</code>来子上文转化后的<code>C2FrameData::buffers(C2Buffer)::mImpl(C2Buffer::Impl)::mData(BufferDataBuddy)::mImpl(C2BufferData::Impl)::mGraphicBlocks(C2ConstGraphicBlock)</code>
至此, <code>GraphicBuffer</code>已经完成从<code>IComponent</code>到<code>mediaserver</code>的传递.</p>
<h2 id="ccodeconworkdone%E5%AE%8C%E6%88%90graphicbuffer%E7%9A%84%E8%BE%93%E5%87%BA"><code>CCodec::onWorkDone()</code>完成<code>GraphicBuffer</code>的输出</h2>
<p>回到<code>HidlListener::onWorkDone()</code>的<code>listener-&gt;onWorkDone()</code>, 其<code>listener</code>类型是<code>Codec2Client::Listener</code>, 其实现是<code>CCodec::ClientListener</code></p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodec.cpp
struct CCodec::ClientListener : public Codec2Client::Listener {
    explicit ClientListener(const wp&lt;CCodec&gt; &amp;codec) : mCodec(codec) {}
    virtual void onWorkDone(
            const std::weak_ptr&lt;Codec2Client::Component&gt;&amp; component,
            std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt;&amp; workItems) override {
        (void)component;
        sp&lt;CCodec&gt; codec(mCodec.promote());
        if (!codec) {
            return;
        }
        codec-&gt;onWorkDone(workItems);
    }
</div></code></pre>
<p>显然<code>codec</code>类型为<code>CCodec</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodec.cpp
void CCodec::onWorkDone(std::list&lt;std::unique_ptr&lt;C2Work&gt;&gt; &amp;workItems) {
    ... ...
    (new AMessage(kWhatWorkDone, this))-&gt;post();
}

void CCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    switch (msg-&gt;what()) {
        case kWhatAllocate:
        ... ...
        case kWhatWorkDone: {
            ... ...
            mChannel-&gt;onWorkDone(
                    std::move(work), outputFormat, initData ? initData.get() : nullptr);
            break;
        }
        ... ...
    }
}
</div></code></pre>
<p><code>mChannel</code>的类型为<code>CCodecBufferChannel</code>:</p>
<pre class="hljs"><code><div>void CCodecBufferChannel::onWorkDone(
        std::unique_ptr&lt;C2Work&gt; work, const sp&lt;AMessage&gt; &amp;outputFormat,
        const C2StreamInitDataInfo::output *initData) {
    if (handleWork(std::move(work), outputFormat, initData)) {
        feedInputBufferIfAvailable();
    }
}

bool CCodecBufferChannel::handleWork(
        std::unique_ptr&lt;C2Work&gt; work,
        const sp&lt;AMessage&gt; &amp;outputFormat,
        const C2StreamInitDataInfo::output *initData) {
    ... ...
    sendOutputBuffers();
    return true;
}

void CCodecBufferChannel::sendOutputBuffers() {
    ... ...
    while (true) {
        ... ...
        switch (action) {
        case OutputBuffers::SKIP:
        ... ...
        case OutputBuffers::NOTIFY_CLIENT:
            output.unlock();
            mCallback-&gt;onOutputBufferAvailable(index, outBuffer);
            break;
        ... ...
        }
    }
}
</div></code></pre>
<p><code>mCallback</code>的类型为<code>MediaCodec::BufferCallback</code>, 所以:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
void BufferCallback::onOutputBufferAvailable(
        size_t index, const sp&lt;MediaCodecBuffer&gt; &amp;buffer) {
    sp&lt;AMessage&gt; notify(mNotify-&gt;dup());
    notify-&gt;setInt32(&quot;what&quot;, kWhatDrainThisBuffer);
    ... ...
    notify-&gt;post();
}

void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        {
            ... ...
            switch (what) {
                case kWhatError:
                ... ...
                case kWhatDrainThisBuffer:
                {
                    ... ...
                    if (mFlags &amp; kFlagIsAsync) {
                        sp&lt;RefBase&gt; obj;
                        CHECK(msg-&gt;findObject(&quot;buffer&quot;, &amp;obj));
                        sp&lt;MediaCodecBuffer&gt; buffer = static_cast&lt;MediaCodecBuffer *&gt;(obj.get());

                        // In asynchronous mode, output format change is processed immediately.
                        handleOutputFormatChangeIfNeeded(buffer);
                        onOutputBufferAvailable();
                    } else ... ...
                    break;
                }
                ... ...
</div></code></pre>
<h3 id="handleoutputformatchangeifneeded%E6%89%93%E5%BC%80%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA"><code>handleOutputFormatChangeIfNeeded()</code>打开音频输出</h3>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp
void MediaCodec::handleOutputFormatChangeIfNeeded(const sp&lt;MediaCodecBuffer&gt; &amp;buffer) {
    ... ...
    if (mFlags &amp; kFlagIsAsync) {
        onOutputFormatChanged();
    } else ... ...
    ... ...
}

void MediaCodec::onOutputFormatChanged() {
    if (mCallback != NULL) {
        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();
        msg-&gt;setInt32(&quot;callbackID&quot;, CB_OUTPUT_FORMAT_CHANGED);
        msg-&gt;setMessage(&quot;format&quot;, mOutputFormat);
        msg-&gt;post();
    }
}
</div></code></pre>
<p><code>CB_OUTPUT_FORMAT_CHANGED</code>被发送到<code>NuPlayer::Decoder::onMessageReceived()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
void NuPlayer::Decoder::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        {
            ... ...
            switch (cbID) {
                case MediaCodec::CB_INPUT_AVAILABLE:
                ... ...
                case MediaCodec::CB_OUTPUT_FORMAT_CHANGED:
                {
                    ... ...
                    handleOutputFormatChange(format);
                    break;
                }
                ... ...

void NuPlayer::Decoder::handleOutputFormatChange(const sp&lt;AMessage&gt; &amp;format) {
    if (!mIsAudio) {
        ... ...
    } else if (mRenderer != NULL) {
        ... ...
        sp&lt;AMessage&gt; reply = new AMessage(kWhatAudioOutputFormatChanged, this);
        reply-&gt;setInt32(&quot;generation&quot;, mBufferGeneration);
        mRenderer-&gt;changeAudioFormat(
                format, false /* offloadOnly */, hasVideo,
                flags, mSource-&gt;isStreaming(), reply);
    }
}
</div></code></pre>
<p><code>mRenderer-&gt;changeAudioFormat()</code>即<code>NuPlayer::Renderer::changeAudioFormat()</code></p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
void NuPlayer::Renderer::changeAudioFormat(
        const sp&lt;AMessage&gt; &amp;format,
        bool offloadOnly,
        bool hasVideo,
        uint32_t flags,
        bool isStreaming,
        const sp&lt;AMessage&gt; &amp;notify) {
    sp&lt;AMessage&gt; meta = new AMessage;
   ... ...
    sp&lt;AMessage&gt; msg = new AMessage(kWhatChangeAudioFormat, this);
    ... ...
    msg-&gt;post();
}

void NuPlayer::Renderer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatOpenAudioSink:
        ... ...
        case kWhatChangeAudioFormat:
        {
            ... ...
            if (queueGeneration != getQueueGeneration(true /* audio */)
                    || mAudioQueue.empty()) {
                onChangeAudioFormat(meta, notify);
                break;
            }
            ... ...
            break;
        }
        ... ...

void NuPlayer::Renderer::onChangeAudioFormat(
        const sp&lt;AMessage&gt; &amp;meta, const sp&lt;AMessage&gt; &amp;notify) {
    ... ...
    status_t err = onOpenAudioSink(format, offloadOnly, hasVideo, flags, isStreaming);
    ... ...
    notify-&gt;post();
}

status_t NuPlayer::Renderer::onOpenAudioSink(
        const sp&lt;AMessage&gt; &amp;format,
        bool offloadOnly,
        bool hasVideo,
        uint32_t flags,
        bool isStreaming) {
    ... ...
    if (!offloadOnly &amp;&amp; !offloadingAudio()) {
        ... ...
        status_t err = mAudioSink-&gt;open(
                    sampleRate,
                    numChannels,
                    (audio_channel_mask_t)channelMask,
                    audioFormat,
                    0 /* bufferCount - unused */,
                    mUseAudioCallback ? &amp;NuPlayer::Renderer::AudioSinkCallback : NULL,
                    mUseAudioCallback ? this : NULL,
                    (audio_output_flags_t)pcmFlags,
                    NULL,
                    doNotReconnect,
                    frameCount);
        ... ...
    }
    if (audioSinkChanged) {
        onAudioSinkChanged();
    }
    mAudioTornDown = false;
    return OK;
}
</div></code></pre>
<p>而<code>AudioOutput::open()</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
status_t MediaPlayerService::AudioOutput::open(
        uint32_t sampleRate, int channelCount, audio_channel_mask_t channelMask,
        audio_format_t format, int bufferCount,
        AudioCallback cb, void *cookie,
        audio_output_flags_t flags,
        const audio_offload_info_t *offloadInfo,
        bool doNotReconnect,
        uint32_t suggestedFrameCount)
{
    ... ...
    if (!(reuse &amp;&amp; bothOffloaded)) {
        ALOGV(&quot;creating new AudioTrack&quot;);

        if (mCallback != NULL) {
            newcbd = new CallbackData(this);
            t = new AudioTrack(
                    mStreamType,
                    sampleRate,
                    format,
                    channelMask,
                    frameCount,
                    flags,
                    CallbackWrapper,
                    newcbd,
                    0,  // notification frames
                    mSessionId,
                    AudioTrack::TRANSFER_CALLBACK,
                    offloadInfo,
                    mAttributionSource,
                    mAttributes,
                    doNotReconnect,
                    1.0f,  // default value for maxRequiredSpeed
                    mSelectedDeviceId);
        } else ...
    }
    ... ...
    mTrack = t;
    return updateTrack();
}
</div></code></pre>
<h3 id="onoutputbufferavailable"><code>onOutputBufferAvailable()</code></h3>
<pre class="hljs"><code><div>void MediaCodec::onOutputBufferAvailable() {
    ... ...
    while ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= 0) {
        ... ...
        msg-&gt;setInt32(&quot;callbackID&quot;, CB_OUTPUT_AVAILABLE);
        ... ...
        statsBufferReceived(timeUs, buffer);
        msg-&gt;post();
    }
}
</div></code></pre>
<p><code>msg-&gt;post()</code>的消息讲由上层的<code>NuPlayer::Decoder::onMessageReceived()</code>处理:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
void NuPlayer::Decoder::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        {
            ... ...
            int32_t cbID;
            CHECK(msg-&gt;findInt32(&quot;callbackID&quot;, &amp;cbID));
            ... ...
            switch (cbID) {
                ... ...
                case MediaCodec::CB_OUTPUT_AVAILABLE:
                {
                    ... ...
                    handleAnOutputBuffer(index, offset, size, timeUs, flags);
                    break;
                }
                ... ....

bool NuPlayer::Decoder::handleAnOutputBuffer(
        size_t index,
        size_t offset,
        size_t size,
        int64_t timeUs,
        int32_t flags) {
    ... ...
    notifyResumeCompleteIfNecessary();
    if (mRenderer != NULL) {
        // send the buffer to renderer.
        mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply);
        if (eos &amp;&amp; !isDiscontinuityPending()) {
            mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM);
        }
    }
    return true;
}
</div></code></pre>
<p>对于音频输出, <code>mRenderer</code>是成立的, 类型为<code>NuPlayer::Renderer</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
void NuPlayer::Renderer::queueBuffer(
        bool audio,
        const sp&lt;MediaCodecBuffer&gt; &amp;buffer,
        const sp&lt;AMessage&gt; &amp;notifyConsumed) {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatQueueBuffer, this);
    ... ...
    msg-&gt;post();
}

void NuPlayer::Renderer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatOpenAudioSink:
        ... ...
        case kWhatQueueBuffer:
        {
            onQueueBuffer(msg);
            break;
        }
        ... ...

void NuPlayer::Renderer::onQueueBuffer(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    sp&lt;RefBase&gt; obj;
    CHECK(msg-&gt;findObject(&quot;buffer&quot;, &amp;obj));
    sp&lt;MediaCodecBuffer&gt; buffer = static_cast&lt;MediaCodecBuffer *&gt;(obj.get())
    ... ...
    QueueEntry entry;
    entry.mBuffer = buffer;
    ... ...
    if (audio) {
        Mutex::Autolock autoLock(mLock);
        mAudioQueue.push_back(entry);
        postDrainAudioQueue_l();
    } else {
        mVideoQueue.push_back(entry);
        postDrainVideoQueue();
    }
    ... ...
    syncQueuesDone_l();
}
</div></code></pre>
<h4 id="postdrainaudioqueuel%E5%9B%9E%E6%94%BE%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE"><code>postDrainAudioQueue_l()</code>回放音频数据</h4>
<pre class="hljs"><code><div>void NuPlayer::Renderer::postDrainAudioQueue_l(int64_t delayUs) {
    ... ...
    sp&lt;AMessage&gt; msg = new AMessage(kWhatDrainAudioQueue, this);
    msg-&gt;setInt32(&quot;drainGeneration&quot;, mAudioDrainGeneration);
    msg-&gt;post(delayUs);
}
</div></code></pre>
<h5 id="audiooutputwrite%E8%BE%93%E5%87%BA%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE"><code>AudioOutput::write()</code>输出音频数据</h5>
<pre class="hljs"><code><div>void NuPlayer::Renderer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatOpenAudioSink:
        ... ...

        case kWhatDrainAudioQueue:
        {
            ... ...
            int32_t generation;
            CHECK(msg-&gt;findInt32(&quot;drainGeneration&quot;, &amp;generation));
            ... ...
            if (onDrainAudioQueue()) {
                ... ...
                postDrainAudioQueue_l(delayUs);
            }
            break;
        }
        ... ...

bool NuPlayer::Renderer::onDrainAudioQueue() {
    ... ...
    while (!mAudioQueue.empty()) 
        ... ...
        ssize_t written = mAudioSink-&gt;write(entry-&gt;mBuffer-&gt;data() + entry-&gt;mOffset,
                                            copy, false /* blocking */);
        ... ...
        }
    }
    ... ...
    return reschedule;
}
</div></code></pre>
<h6 id="audiotrackwrite%E5%9B%9E%E6%94%BE%E9%9F%B3%E9%A2%91"><code>AudioTrack::write()</code>回放音频</h6>
<p><code>NuPlayer::Render</code>的<code>mAudioSink</code>为创建时由<code>NuPlayer</code>传递的, 因此<code>AudioOutput::write()</code>被调用:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
ssize_t MediaPlayerService::AudioOutput::write(const void* buffer, size_t size, bool blocking)
{
    Mutex::Autolock lock(mLock);
    LOG_ALWAYS_FATAL_IF(mCallback != NULL, &quot;Don't call write if supplying a callback.&quot;);

    //ALOGV(&quot;write(%p, %u)&quot;, buffer, size);
    if (mTrack != 0) {
        return mTrack-&gt;write(buffer, size, blocking);
    }
    return NO_INIT;
}
</div></code></pre>
<p><code>mTrack</code>正式<code>AudioOutput::open()</code>时打开的<code>AudioTrack</code>.</p>
<h4 id="postdrainvideoqueue%E5%9B%9E%E6%94%BE%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE"><code>postDrainVideoQueue()</code>回放视频数据</h4>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
void NuPlayer::Renderer::postDrainVideoQueue() {
    ... ...
    QueueEntry &amp;entry = *mVideoQueue.begin();

    sp&lt;AMessage&gt; msg = new AMessage(kWhatDrainVideoQueue, this);
    msg-&gt;setInt32(&quot;drainGeneration&quot;, getDrainGeneration(false /* audio */));
    ... ...
    if (!mVideoSampleReceived || mediaTimeUs &lt; mAudioFirstAnchorTimeMediaUs) {
        msg-&gt;post();
    } else {
        int64_t twoVsyncsUs = 2 * (mVideoScheduler-&gt;getVsyncPeriod() / 1000);

        // post 2 display refreshes before rendering is due
        mMediaClock-&gt;addTimer(msg, mediaTimeUs, -twoVsyncsUs);
    }
    mDrainVideoQueuePending = true;
}

void NuPlayer::Renderer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatOpenAudioSink:
        ... ...
        case kWhatDrainVideoQueue:
        {
            ... ...
            onDrainVideoQueue();
            postDrainVideoQueue();
            break;
        }
        ... ...

void NuPlayer::Renderer::onDrainVideoQueue() {
    ... ...
    entry-&gt;mNotifyConsumed-&gt;setInt64(&quot;timestampNs&quot;, realTimeUs * 1000LL);
    entry-&gt;mNotifyConsumed-&gt;setInt32(&quot;render&quot;, !tooLate);
    entry-&gt;mNotifyConsumed-&gt;post();
    ... ...
}
</div></code></pre>
<p><code>entry-&gt;mNotifyConsumed</code>通知了<code>NuPlayer::Decoder</code>:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
void NuPlayer::Decoder::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    ALOGV(&quot;[%s] onMessage: %s&quot;, mComponentName.c_str(), msg-&gt;debugString().c_str());

    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        ... ...
        case kWhatRenderBuffer:
        {
            if (!isStaleReply(msg)) {
                onRenderBuffer(msg);
            }
            break;
        }
        ... ...

void NuPlayer::Decoder::onRenderBuffer(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    if (mCodec == NULL) {
        err = NO_INIT;
    } else if (msg-&gt;findInt32(&quot;render&quot;, &amp;render) &amp;&amp; render) {
        int64_t timestampNs;
        CHECK(msg-&gt;findInt64(&quot;timestampNs&quot;, &amp;timestampNs));
        err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs);
    } else {
        if (!msg-&gt;findInt32(&quot;eos&quot;, &amp;eos) || !eos ||
                !msg-&gt;findSize(&quot;size&quot;, &amp;size) || size) {
            mNumOutputFramesDropped += !mIsAudio;
        }
        err = mCodec-&gt;releaseOutputBuffer(bufferIx);
    }
    ... ...
}
</div></code></pre>
<p>此场景下<code>renderOutputBufferAndRelease()</code>被调用:</p>
<pre class="hljs"><code><div>// frameworks/av/media/libstagefright/MediaCodec.cpp

status_t MediaCodec::renderOutputBufferAndRelease(size_t index, int64_t timestampNs) {
    sp&lt;AMessage&gt; msg = new AMessage(kWhatReleaseOutputBuffer, this);
    msg-&gt;setSize(&quot;index&quot;, index);
    msg-&gt;setInt32(&quot;render&quot;, true);
    msg-&gt;setInt64(&quot;timestampNs&quot;, timestampNs);

    sp&lt;AMessage&gt; response;
    return PostAndAwaitResponse(msg, &amp;response);
}

status_t MediaCodec::PostAndAwaitResponse(
        const sp&lt;AMessage&gt; &amp;msg, sp&lt;AMessage&gt; *response) {
    status_t err = msg-&gt;postAndAwaitResponse(response);
    ... ...
    return err;
}
</div></code></pre>
<h5 id="mediacodeconreleaseoutputbuffer%E9%87%8A%E6%94%BE%E5%B9%B6%E8%BE%93%E5%87%BA%E8%A7%86%E9%A2%91%E5%B8%A7"><code>MediaCodec::onReleaseOutputBuffer()</code>释放(并输出)视频帧</h5>
<p><code>kWhatReleaseOutputBuffer</code>消息由<code>MediaCodec::onMessageReceived()</code>处理:</p>
<pre class="hljs"><code><div>void MediaCodec::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) {
    switch (msg-&gt;what()) {
        case kWhatCodecNotify:
        ... ...
        case kWhatReleaseOutputBuffer:
        {
            ... ...
            status_t err = onReleaseOutputBuffer(msg);
            PostReplyWithError(replyID, err);
            break;
        }
        ... ...

status_t MediaCodec::onReleaseOutputBuffer(const sp&lt;AMessage&gt; &amp;msg) {
    ... ...
    if (render &amp;&amp; buffer-&gt;size() != 0) {
        ... ...
        status_t err = mBufferChannel-&gt;renderOutputBuffer(buffer, renderTimeNs);
        ... ...
</div></code></pre>
<h6 id="codec2clientcomponentqueuetooutputsurface%E4%BA%A4%E6%8D%A2%E8%A7%86%E9%A2%91%E5%B8%A7%E5%88%B0%E5%BA%94%E7%94%A8%E7%9A%84bbqsurface"><code>Codec2Client::Component::queueToOutputSurface()</code>交换视频帧到应用的<code>BBQSurface</code></h6>
<p>显然<code>mBufferChannel</code>的类型是<code>CCodecBufferChannel</code>, 因此:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/sfplugin/CCodecBufferChannel.cpp
status_t CCodecBufferChannel::renderOutputBuffer(
    ... ...
    status_t result = mComponent-&gt;queueToOutputSurface(block, qbi, &amp;qbo);
    ... ...
    mCCodecCallback-&gt;onOutputFramesRendered(mediaTimeUs, timestampNs);
    return OK;
}
</div></code></pre>
<p><code>mComponent</code>的类型是<code>Codec2Client::Component</code>, 因此:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/client.cpp
status_t Codec2Client::Component::queueToOutputSurface(
        const C2ConstGraphicBlock&amp; block,
        const QueueBufferInput&amp; input,
        QueueBufferOutput* output) {
    return mOutputBufferQueue-&gt;outputBuffer(block, input, output);
}
</div></code></pre>
<p><code>mOutputBufferQueue</code>的类型是<code>mOutputBufferQueue</code>, 因此:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/hidl/client/output.cpp
status_t OutputBufferQueue::outputBuffer(
        const C2ConstGraphicBlock&amp; block,
        const BnGraphicBufferProducer::QueueBufferInput&amp; input,
        BnGraphicBufferProducer::QueueBufferOutput* output) {
    ... ...
    if (!getBufferQueueAssignment(block, &amp;generation, &amp;bqId, &amp;bqSlot) ||
        bqId == 0) {
        ... ...
    }
    auto syncVar = syncMem ? syncMem-&gt;mem() : nullptr;
    status_t status = OK;
    if (syncVar) {
        ... ...
    } else {
        status = outputIgbp-&gt;queueBuffer(static_cast&lt;int&gt;(bqSlot),
                                                  input, output);
    }
    ... ...
}

bool getBufferQueueAssignment(const C2ConstGraphicBlock&amp; block,
                              uint32_t* generation,
                              uint64_t* bqId,
                              int32_t* bqSlot) {
    return _C2BlockFactory::GetBufferQueueData(
            _C2BlockFactory::GetGraphicBlockPoolData(block),
            generation, bqId, bqSlot);
}
</div></code></pre>
<p>关于Buffer的处理:</p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/vndk/C2Buffer.cpp
std::shared_ptr&lt;_C2BlockPoolData&gt; _C2BlockFactory::GetGraphicBlockPoolData(
        const C2Block2D &amp;block) {
    if (block.mImpl) {
        return block.mImpl-&gt;poolData();
    }
    return nullptr;
}
</div></code></pre>
<p><code>block</code>(类型: <code>C2Block2D</code>)的<code>mImpl</code>成员类型为: <code>_C2MappingBlock2DImpl</code>, 其实现为<code>C2Block2D::Impl</code>, 其<code>poolData()</code>返回<code>C2Block2D::Impl</code>的<code>mPoolData</code>成员, 其类型为<code>_C2BlockPoolData</code>, 其实现为<code>C2BufferQueueBlockPoolData</code>, 继续<code>_C2BlockFactory::GetBufferQueueData()</code></p>
<pre class="hljs"><code><div>// frameworks/av/media/codec2/vndk/C2Buffer.cpp
bool _C2BlockFactory::GetBufferQueueData(
        const std::shared_ptr&lt;const _C2BlockPoolData&gt;&amp; data,
        uint32_t* generation, uint64_t* bqId, int32_t* bqSlot) {
    if (data &amp;&amp; data-&gt;getType() == _C2BlockPoolData::TYPE_BUFFERQUEUE) {
        const std::shared_ptr&lt;const C2BufferQueueBlockPoolData&gt; poolData =
                std::static_pointer_cast&lt;const C2BufferQueueBlockPoolData&gt;(data);
        poolData-&gt;getBufferQueueData(generation, bqId, bqSlot);
        return true;
    }
    return false;
}

void C2BufferQueueBlockPoolData::getBufferQueueData(
        uint32_t* generation, uint64_t* bqId, int32_t* bqSlot) const {
    if (generation) {
        std::scoped_lock&lt;std::mutex&gt; lock(mLock);
        *generation = mGeneration;
        if (bqId) {
            *bqId = mBqId;
        }
        if (bqSlot) {
            *bqSlot = mBqSlot;
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div>经过`getBufferQueueAssignment()`将得到`bqId`和`bqSlot`

回到`OutputBufferQueue::outputBuffer()`, `outputIgbp-&gt;queueBuffer()`将索引为`bqSlot`的`GraphicBuffer`, 发送给应用. 此时`mIgbp`的类型是`IGraphicBufferProducer`, 其实现是`BpGraphicBufferProducer`, Binder对端是应用此前所持有的`BBQSurface`中的`BBQBufferQueueProducer`, 继承关系为:`IGraphicBufferProducer` -&gt; `BnGraphicBufferProducer` -&gt; `BufferQueueProducer` -&gt; `BBQBufferQueueProducer`</div></code></pre>

</body>
</html>
